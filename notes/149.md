149 Study Guide
=================

Notes created while preparing for Assessment 149. This assessment is designed to test knowledge of courses 120 and 130 and will mainly focus on Object Oriented Programming concepts, though all prior material is fair game as well.

Classes and Objects
--------------------

Historically, a program has been viewed as a procedure that takes input data, processes it with step-by-step instructions, and provides output data. This is often referred to as procedural programming.

**Object Oriented Programming** (OOP) is a paradigm that was created to deal with the growing complexity of large programs. Programmers needed a way to change a piece of a program without adversely affecting other pieces of the program.

OOP addresses this by using containers to group related attributes (or data) and behavior (or instructions). The container is called an **object** and the **class** is an outline of the possible states (attributes) and behaviors of that object.

In Ruby, everything is an object. Strings, Arrays, Hashes, and Integers are all types of objects. And the properties and methods available to each of these object types is outlined in their class.

Instantiation
-------------

The process of creating a new object is called **instantiation**. In the example below, an instance of the Dog class was created and stored in the variable `my_dog`.

```ruby
class Dog
end

my_dog = Dog.new
```

Let's modify the class by adding an `initialize` method. When defined, `initialize` is called each time a new object is created. This type of method is known as a constructor.

```ruby
class Dog
  def initialize
    puts "You created a new Dog!"
  end
end

my_dog = Dog.new # => "You created a new Dog!"
```

Instance Methods and Instance Variables
---------------------------------------

Instance methods define the behaviors available to an object. The `Dog` class below has a `bark` method that can be called on any `Dog` object.

```ruby
class Dog
  def bark
    puts "Woof!"
  end
end

my_dog = Dog.new
my_dog.bark # outputs "Woof!"
```

Instance variables (`@`) store information about the state of an object. The `Dog` class below has a `name` attribute. And there are two instance methods that allow an object to assign (`set_name`) and retrieve (`get_name`) the name of a `Dog` object.  

```ruby
class Dog
  def set_name=(name)
    @name = name
  end

  def get_name
    @name
  end
end

my_dog = Dog.new
your_dog = Dog.new
my_dog.set_name("Fitz")
your_dog.set_name("Freddy")
my_dog.get_name # => returns "Fitz"
```

Even though `my_dog` and `your_dog` are different objects, since they are both instances of the `Dog` class, the same behaviors (methods) are available to both. The state of each object, however, may be different and is tracked by the values of its attributes, in this case, just the `name` instance variable.

Accessor Methods (Getter/Setter)
----------------

The two methods from the previous example are known as accessor methods.  More specifically, `set_name` is a `setter` method and `get_name` is a `getter` method. Because these methods are so common, Ruby has a built-in way to automatically create them for us, using the **attr_accessor** method. The example code below is practically equivalent to (and much shorter than) the previous example.

```ruby
class Dog
  attr_accessor :name
end

my_dog = Dog.new
my_dog.name = "Fitz"
my_dog.name # => returns "Fitz"
```

To create just a `getter` method, use `attr_reader` instead, and to create just a `setter` method, use `attr_writer`.

Self
----

In the example below, `my_dog` is adopted by an owner, and we expect the value of the `owner` variable to be updated. But something goes wrong!

```ruby
class Dog
  attr_accessor :name, :owner

  def initialize(name, owner = "none")
    @name = name
    @owner = owner
  end

  def adopted_by(name)
    owner = name
  end
end

my_dog = Dog.new("Fitz")
my_dog.adopted_by("Carlos")
my_dog.owner # => "none"
```

The problem is that Ruby thinks we're trying to create a local variable, `owner`. This is a consequence of our expectations of Ruby's syntactical sugar. To clarify what we want, which is to call the setter method, `self` is used below.

```ruby
class Dog
  attr_accessor :name, :owner

  def initialize(name, owner = "none")
    @name = name
    @owner = owner
  end

  def adopted_by(name)
    self.owner = name
  end
end

my_dog = Dog.new("Fitz")
my_dog.adopted_by("Carlos")
my_dog.owner # => "Carlos"
```

Calling `self` from within an instance method creates a reference to the calling object, in this case, `my_dog`. So `self.owner` is the essentially the same as `my_dog.owner`

Another use of `self` involves class methods. Class methods are for functionality that doesn't pertain to an individual object. A class method is called directly on the class itself and is defined by prepending a method name with `self`.

```ruby
class Dog
  def self.what_am_i
    puts "I'm a Dog class."
  end
end

Dog.what_am_i # outputs "I'm a Dog class."
```

So when `self` is called inside a class but outside an instance method, it refers to the class itself. `def self.method` is essentially the same as `def Dog.method`.

Inheritance
-----------

Inheritance is when a class inherits behavior from another class. In the example below, `Dog` subclasses `Animal` and inherits all of its methods. Therefore, `my_dog` is able to use the `speak` method from the `Animal` class.

```ruby
class Animal
  def speak
    "Hello!"
  end
end

class Dog < Animal
end

my_dog = Dog.new
my_dog.speak # outputs "Hello!"
```

In the example below, `Dog`overrides the `speak` method from  `Animal`. This is because Ruby first checks an object's class for a method before looking in its superclass.

```ruby
class Animal
  def speak
    "Hello!"
  end
end

class Dog < Animal
  def speak
    "Woof!"
  end
end

my_dog = Dog.new
my_dog.speak # => "Woof!"
```

It's important to remember that every custom class inherently subclasses from the `Object` class and therefore has access to its methods. It's generally recommended to not override these methods. One exception is `to_s`.

Super
------

Ruby provides a built-in function called `super` that allows us to directly call a method from an object's superclass. When called, `super` will search the inheritance hierarchy for a method of the same name and invoke it.

```ruby
class Animal
  def speak
    "Hello!"
  end
end

class Dog < Animal
  def speak
    super + " Woof!"
  end
end

my_dog = Dog.new
my_dog.speak # => "Hello! Woof!"
```

A common way of using `super` is with `initialize`. In this example, the `name` argument is passed on to the superclass, which assigns its value to the `@name` instance variable.

```ruby
class Animal
  def initialize(name)
    @name = name
  end
end

class Dog < Animal
  attr_reader :name, :color

  def initialize(name, color)
    super(name)
    @color = color
  end
end

my_dog = Dog.new("Fitz", "Brown")
my_dog.name # => "Fitz"
my_dog.color # => "Brown"
```

Module Mix-in
-------------

Like a class, a module is another way to group related behaviors. Unlike a class, you cannot instantiate a module object nor can you subclass a module. Modules are primarily used to add ("mix in") functionality to an existing class.  To use a module's functionality,  the `include` keyword is placed in the class definition. In the example below, `Dog` and `Human` have been given access to the `speak` method.

```ruby
module Speak
  def speak
    "Hello!"
  end
end

class Dog
  include Speak
end

class Human
  include Speak
end

my_dog = Dog.new
my_dog.speak # => "Hello!"
my = Human.new
me.speak # => "Hello!"
```

While you can only inherit from one class, you can mix in any number of modules. Inheritance is generally used for an "is a" relationship, while modules are used for a "has a" relationship. For example, a dog *is a* animal and a dog *has a* ability to speak.  

Modules are also used to act as a namespace, allowing you to define methods whose names will not clash with methods of the same name.

Method Lookup Path
------------------

Ruby has a distinct path it follows to look for a method that is called. As shown in the example below, after first looking in the calling object's class, it next looks within any included modules, and lastly within an object's superclass. When handling multiple modules, Ruby actually looks at the last included module and works from the bottom up.

```ruby
module Swimmable
end

module Climbable
end

class Animal
end

class Dog < Animal
  include Swimmable
end

p Dog.ancestors # => [Dog, Climbable, Swimmable, Animal, Object, Kernel, BasicObject]
```

Private, Protected, and Public
-------------------------------

A **public method** is accessible to anyone who knows either the class or object's name. Public methods comprise a class's *interface*, or how other classes and objects can interact with the class and its objects.

Unlike public methods, **private methods** and **protected methods** are only accessible from within other methods of the class.

The difference is that a **private method** can only be called from the calling object. It cannot access another object's private methods directly and it cannot use `self`.

Collaborator Objects
--------------------

Instance variables can actually hold any kind of object, even that of a custom class. In the example below, `fitz`, a `Dog` object, is assigned to `@pet`. So when we call `me.pet`, it returns a `Dog` object.

Working with collaborator objects in your class is no different than working with strings, integers, or arrays.

```ruby
class Dog
  def initialize(name)
    @name = name
  end
end

class Person
  attr_accessor :name, :pet

  def initialize(name)
    @name = name
  end
end

me = Person.new("Nitin")
fitz = Dog.new("Fitz")

me.pet = fitz
```

Fake Operators
--------------

Ruby aims to be concise and succinct. This allows programmers to concentrate more on the problem they're trying to solve. To meet this aim, the language contains a lot of "syntactical sugar", special syntax that creates a more natural language of code while hiding what's actually going on underneath. For example, instead of calling `String#==` like most methods (eg. str1.==(str2)), we call it with a special syntax that reads more naturally (eg. str1 == str2). A consequence of Ruby's syntactical sugar is that it's often difficult to know if code contains an operator or is actually a method disguised as a "fake operator".

#### Real Operators

| **Operator**                                  | **Description**               |
| ----------------                              | -------------                 |
| `&&`                                          | Logical "and"                 |
| <code>&#124;&#124;</code>                     | Logical "or"                  |
| `..`, `...`                                   | Inclusive and exclusive range |
| `? :`                                         | Ternary if-then-else          |
| `=`, `+=`, `-=`, `%=`, `*=`, `/=`, `%=`, `%=` | Assignment (and shortcuts)    |

#### Fake Operators

| **Method**              | **Description**                       |
| ----------------        | -------------                         |
| `[]`, `[]=`             | Collection getter/setter              |
| `**`                    | Exponential operator                  |
| `!`, `~`                | Not, complement                       |
| `+`, `-`, `%`, `*`, `/` | Plus, minus, modulo, multiply, divide |
| `<<`, `<<`              | Right and left shift                  |
| `<`, `<=`, `>`, `>=`    | Less than, greater than, or equal to  |
| '<=>', `==`, `!=`, `=~` | Equality and pattern matching         |


Because the fake operators are actually methods, their functionality can be overridden in a custom class.

```ruby
class Dog
  attr_reader :age

  def initialize(name, age)
    @name = name
    @age = age
  end

  def ==(other_dog)
    age == other_dog.age
  end
end

my_dog = Dog.new("Fitz", 2)
your_dog = Dog.new("Freddy", 2)

my_dog.==(your_dog) # => true
my_dog == your_dog # => true
```

Let's examine the `[]` and `[]=` methods. The two groups of code below are equivalent. The second example takes advantage of Ruby's special syntax and reads more naturally.

```ruby
array = ["Fitz", "Freddy"]

array.[](1) # => "Freddy"
array.[]=(2, "Titan") # => "Titan"
array # => ["Fitz", "Freddy", "Titan"]
```

```ruby
array = ["Fitz", "Freddy"]

array[1] # => "Freddy"
array[2] = "Titan" # => "Titan"
array # => ["Fitz", "Freddy", "Titan"]
```

Truthiness and false vs. nil
-----------------------------

In Ruby, to express "nothing", `nil` is used, and `nil` evaluates to `false`. But while both `nil` and `false` both evaluate to `false`, they are not equivalent.

```ruby
false.class # => FalseClass
!!nil # => false
!!false # => false
nil == false # => false
```

Other than `false` and `nil`, Ruby considers everything to be truthy.

```ruby
true.class # => TrueClass
!!true # => true
!!0 # => true
!!"" # => true
!!(num == 0) # => true
!!(num = 0) # => true
```

This means we can use any expression in a conditional, and as long as it doesn't evaluate to `false` or `nil`, it is considered true.

```ruby
num = 5
!!(num = 5) # => true
num == true # => false
!!num == !!true # => true

puts "Hello!" if num # outputs "Hello!"
```

Logical Operators
------------------

The `&&` and `||` operators exhibit a behavior called **short circuiting**, which means an expression will stop evaluating when the return value is guaranteed.

```ruby
false && 3/0 # => false
true || 3/0 # => true
```

```ruby
3/0 && false # => ZeroDivisionError: divided by 0
3/0 || true # => ZeroDivisionError: divided by 0
```

Even though `3/0` is invalid code and will raise a `ZeroDivisionError`, it doesn't in the first set of examples. The reason is that `3/0` is never actually evaluated because the return value is already guaranteed by the first expression in each example. When you reverse the order of the expressions, you'll now see the error.


Instance Variable Scope
-----------------------

Instance variables start with `@` and are scoped at the object level. Unlike local variables, they are accessible within any instance method, even if initialized in a different instance method.

```ruby
class Dog
  def initialize(name)
    @name = name
  end

  def get_name
    @name
  end
end

my_dog = Dog.new("Fitz")
my_dog.get_name # => "Fitz"
```

Also unlike local variables, when accessing an instance variable that hasn't been initialized, `nil` is returned. An uninitialized local variable raises a `NameError`.

```ruby
class Dog
  def get_name
    @name
  end
end

my_dog = Dog.new
my_dog.get_name # => nil
```

Instance variables initialized in a superclass are also accessible. In the example below, `Dog` subclasses `Animal`, so when a `Dog` object is instantiated, it looks for `initialize`. Since it can't find it in the `Dog` class, it proceeds up the method lookup path and finds `initialize` method in the `Animal` class. The `@name` instance variable is initialized and belongs to the `Dog` object.

```ruby
class Animal
  def initialize(name)
    @name = name
  end
end

class Dog < Animal
  def to_s
    "Woof! My name is #{@name}."
  end
end

my_dog = Dog.new("Fitz")
puts my_dog.to_s # => "Woof! My name is Fitz."
```

Class Variable Scope
-----------------------

Class variables start with `@@` and are scoped at the class level. All objects share one copy of a class variable. Class methods can access a class variable regardless of where it's initialized.

```ruby
class Dog
  @total_dogs = 0

  def initialize
    @@total_dogs += 1
  end

  def total_dogs
    @@total_dogs
  end
end

Dog.total_dogs # => 0
my_dog = Dog.new
Dog.total_dogs # => 1
your_dog = Dog.new
Dog.total_dogs # => 2
```

It's possible for a class variable in a subclass to affect the class variable in a superclass. For this reason, class variables are generally avoided, especially when working with inheritance.

Constant Variable Scope
-----------------------

Constants begin with a capital letter and have lexical scope. Unlike class and instance variables, constants from completely separate classes are accessible with the appropriate syntax.

```ruby
class Dog
  LEGS = 4
end

class Human
  LEGS = 2

  def legs
    "I have #{LEGS} legs and my dog has #{Dog::LEGS} legs."
  end
end

me = Human.new
me.legs # => "I have 2 legs and my dog has 4 legs."
```
As expected, a constant initialized in a superclass can be accessed by both class and instance methods. With modules however, you must specify which class defines the constant.

```ruby
module Legs
  def legs
    "I have #{Dog::LEGS} legs"
  end
end

class Dog
  include Legs

  LEGS = 4
end

my_dog = Dog.new
my_dog.legs # => "I have 4 legs."
```

Closures
--------

A closure is a concept that allows programmers to save a "chunk of code" and execute it later. In addition to saving the code, a closure binds its surrounding variables, methods, and objects so they can be referenced when the closure is executed. In Ruby, a closure is implemented with a block, `Proc` object, or lambda.

### Blocks

A block is often passed as an argument to a method call. In the example below, the block is the code between the `do ... end`.

```ruby
[1, 2, 3].select do |num|
  num.odd?
end
# => [1, 3]
```

In Ruby, every method can take an optional block as an implicit parameter. It's up to the method implementation to decide what to do with the block of code given to it, and most will ignore it.

```ruby
puts("hello") { " goodbye!" } # outputs "hello"
```

If a method wants to use the block, the `yield` keyword will return the value of the block to the method.  

```ruby
def print_block(arg1)
  puts arg1 + yield
end

print_block("hello") { " goodbye!" } # outputs "hello goodbye!"

print_block("hello") # => LocalJumpError: no block given (yield)
```

A method containing a `yield` means that after the method is implemented, additional code can be injected into the method at a later time (without modifying the method implementation) by passing in a block. This is one of the major use cases for blocks.

If a block isn't provided, however, the method will raise a `LocalJumpError`. The `Kernel#block_given?` method can be used to make the block optional.

```ruby
def print_block(arg1)
  puts(block_given? ? arg1 + yield : arg1)
end

print_block("hello") { " goodbye!" } # outputs "hello goodbye!"
print_block("hello") # outputs "hello"
```

When called (or yielded to), a block can be passed in arguments of its own. In the example below, the value of `number + 1` is passed to the block and assigned to the block local variable `num`.

```ruby
def increment(number)
  block_given? ? yield(number + 1) : (number + 1)
end

increment(5) # => 6

increment(5) do |num|
  num + 1
end # => 7
```

Top Use Cases for Blocks:

1. Give the method caller more power and flexibility when invoking the method.

```ruby
[1, 2, 3].select do |num|
  num.odd?
end
# => [1, 3]
```

2. Sandwich code — when a method implementor wants to allow a method caller to do something before and after an action but doesn't care what that action is. The code placed in the block becomes that action.  

```ruby
File.open("some_file.txt", "w+") do |file|
  # write to this file using file.write
end
```

### Procs

A `Proc` allows you to actually save a block to a variable. As an object, a `Proc` can be directly passed into a method and has more flexibility to be passed around throughout a program. Unlike with implicit blocks, a `Proc` is executed using the `Proc#call` method.

```ruby
a = Proc.new { "stored in proc"}

def increment(proc1)
  puts proc1.call
end

increment(a) # outputs "stored in proc"
```

Multiple `Proc` objects can be passed into a method in this way, while just one block can be passed as an argument.

### Lambdas

```ruby
proc = Proc.new { "block"}
lam = lambda { "block" }

proc # => #<Proc:0x007fc6b7a8eed8@(irb):30>
lam # => #<Proc:0x007fc6b80a67a8@(irb):31 (lambda)>
```

A `lambda` is a type of `Proc` object. There are a couple key differences though. The first is arity; a `lambda` enforces the number of arguments, while a `Proc` does not. The second difference is how they each treat the `return` keyword.

```ruby
def lambda_test
  lam = lambda { return }
  lam.call
  puts "Hello!"
end

def proc_test
  proc = Proc.new { return }
  proc.call
  puts "Hello!"
end

lambda_test # outputs "Hello!"
proc_test # outputs nothing
```

Inside a `lambda`, a `return` jumps back to the code right after the lambda was called. Inside a `Proc`, a `return` jumps outside the method where the `Proc` was called.

```ruby
def call_me(some_code)
  some_code.call
end

name = "Robert"
chunk_of_code = Proc.new {puts "hi #{name}"}
name = nil

call_me(chunk_of_code)
```

Arity
-----

Calling a block is kind of like calling a method. Unlike a method though, blocks have lenient arity. **Arity** refers to the enforcement of the number of arguments you can call.

A method requires the correct number of arguments are passed. Like a method, a `lambda` enforces the number of arguments. An error is thrown if the correct number of arguments is not provided.

A `Proc` and an implicit block does not enforce the number of arguments passed in. If a block variable is defined, and no value is passed, `nil` will be assigned to the block variable. Any extra block variables will simply be ignored.

Writing methods that take a block
-------------------------------------

```ruby
def each(array)
  counter = 0
  while counter < array.size
    yield(array[counter])
    counter += 1
  end
  array
end

each([1, 2, 3]) do |num|
  p num
end # outputs each num on separate lines and returns [1, 2, 3]
```

```ruby
def select(array)
  counter = 0
  new_array = []
  while counter < array.size
    current_element = array[counter]
    new_array << current_element if yield(current_element)
    counter += 1
  end
  new_array
end

select([1, 2, 3]) do |num|
  num.odd?
end # => [1, 3]
```

```ruby
def map(array)
  counter = 0
  new_array = []
  while counter < array.size
    new_array << yield(array[counter])
    counter += 1
  end
  new_array
end

map([1, 2, 3]) do |num|
  num + 1
end # => [2, 3, 4]
```

```ruby
def reduce(array, default=0)
  counter = 0
  result = default
  while counter < array.size
    result = yield(result, array[counter])
    counter += 1
  end
  result
end

reduce([1, 2, 3]) do |acc, num|
  acc + num
end # => 6
```
