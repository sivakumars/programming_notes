149 Study Guide
=================

Notes created while preparing for Assessment 149. This assessment is designed to test knowledge of courses 120 and 130 and will mainly focus on Object Oriented Programming concepts, though all prior material is fair game as well.

Classes and Objects
--------------------

Historically, a program has been viewed as a procedure that takes input data, processes it with step-by-step instructions, and provides output data. This is referred to as procedural programming.

**Object Oriented Programming** is a paradigm that was created to deal with the growing complexity of large programs. Programmers needed a way to change a piece of a large program without unexpectedly affecting the entire program.

OOP addresses this concern by using containers to group related attributes (or data) and behavior (or instructions). The container is called an object and the class is the outline of the possible attributes (properties) and behaviors (methods) of that object.

In Ruby, everything is an object. Strings, Arrays, Hashes, and Integers are all types of objects. And the properties and methods available to each of these object types is outlined in their class.

The workflow of creating a new object is called **instantiation.** In the example below, an instance of the Dog class was created and stored in the variable `my_dog`.

```ruby
class Dog
end

my_dog = Dog.new
```

Let's modify the class by adding an `initialize` method. If defined, the `initialize` method is called every time you create a new object. This type of method is known as a constructor.

```ruby
class Dog
  def initialize
    puts "You created a new Dog!"
  end
end

my_dog = Dog.new # => "You created a new Dog!"
```

Instance Methods and Instance Variables
---------------------------------------

Let's add behavior to the class. The Dog class now has a `bark` method that can be called on any Dog object. We define these behaviors as instance methods in a class.

```ruby
class Dog
  def bark
    puts "Woof!"
  end
end

my_dog = Dog.new
my_dog.bark # => outputs "Woof!"
```

Let's add an attribute to the class. The Dog class now has a `name` attribute. In addition, there are a couple new instance methods that allow an object to assign (`set_name`) and retrieve (`get_name`) the name of a Dog object. In addition to `name`, we can allow the object to track other information about a Dog object, like age or weight. In a class, we use instance variables (`@`) to track information about the state of an object. The variable exists as long as the object instance exists.

```ruby
class Dog
  def set_name=(name)
    @name = name
  end

  def get_name
    @name
  end
end

my_dog = Dog.new
my_dog.set_name("Fitz")
my_dog.get_name # => returns "Fitz"
```

Accessor Methods
----------------

The two methods added in the previous example are known as accessor methods.  More specifically, `set_name` is a `setter` method and `get_name` is a `getter` method. Because these methods are so common, Ruby has a built-in way to automatically create them for us, using the **attr_accessor** method. The example code below is practically equivalent to the previous example.

```ruby
class Dog
  attr_accessor :name
end

my_dog = Dog.new
my_dog.name = "Fitz"
my_dog.name # => returns "Fitz"
```

If we only want a `getter` method, we can use `attr_reader` instead, and if we only want a `setter` method, we can use `attr_writer`.

Self
----

In the example below, a Dog is adopted by a new owner, and we expect the value of the `owner` instance variable to be updated. But it doesn't work!

```ruby
class Dog
  attr_accessor :name, :owner

  def initialize(name, owner = "none")
    @name = name
    @owner = owner
  end

  def adopted_by(name)
    owner = name
  end
end

my_dog = Dog.new("Fitz")
my_dog.adopted_by("Carlos")
my_dog.owner # => "none"
```

This is because Ruby thinks we're trying to create a local variable, `owner`, a consequence of our expectations of Ruby's syntactical sugar. To clarify what we want and call the setter method, we must use `self`.

```ruby
class Dog
  attr_accessor :name, :owner

  def initialize(name, owner = "none")
    @name = name
    @owner = owner
  end

  def adopted_by(name)
    self.owner = name
  end
end

my_dog = Dog.new("Fitz")
my_dog.adopted_by("Carlos")
my_dog.owner # => "Carlos"
```

When `self` is called from within an instance method, it refers to the calling object, in this case, the `my_dog` object. So calling `self.owner` is the same as calling `my_dog.owner`

Another use of self involves class methods. Class methods are used for functionality that doesn't pertain to an individual object. A class method is called directly on the class itself, and it is defined by prepending the method name with `self`.

```ruby
class Dog
  def self.what_am_i
    puts "I'm a Dog class."
  end
end

Dog.what_am_i # => outputs "I'm a Dog class."
```

When `self` is called inside a class but outside an instance method, it refers to the class itself. So, `def self.method` is the same as `def Dog.method`.

Inheritance
-----------

Inheritance is when a class inherits behavior from another class. In the example below, `Dog` subclasses `Animal` and inherits all of its methods. Therefore, the `my_dog` object is able to call the `speak` method.

```ruby
class Animal
  def speak
    "Hello!"
  end
end

class Dog < Animal
end

my_dog = Dog.new
my_dog.speak # => outputs "Hello!"
```

In the example below, the `Dog` class overrides the `speak` method from the `Animal` class because Ruby checks the object's class first before looking in the superclass.

```ruby
class Animal
  def speak
    "Hello!"
  end
end

class Dog < Animal
  def speak
    "Woof!"
  end
end

my_dog = Dog.new
my_dog.speak # => "Woof!"
```

Super
------

Ruby provides a built-in function called `super` that allows us to call methods up the inheritance hierarchy. When you call `super`, it will search the hierarchy for a method of the same name and invoke it.

```ruby
class Animal
  def speak
    "Hello!"
  end
end

class Dog < Animal
  def speak
    super + " Woof!"
  end
end

my_dog = Dog.new
my_dog.speak # => "Hello! Woof!"
```

A common way of using `super` is with `initialize`. In this example, the `name` argument is passed to the superclass, which sets it to the `@name` instance variable.

```ruby
class Animal
  def initialize(name)
    @name = name
  end
end

class Dog < Animal
  def initialize(name, color)
    super(name)
    @color = color
  end
end

my_dog = Dog.new("Fitz", "Brown")
```

Module Mix-in
-------------

Like classes, modules contain shared behavior. But you cannot instantiate an object with a module. To use a module's methods, it must be "mixed in" to a class using `include`. In the example below, both `Dog` and `Human` have access to the `speak` instance method.

```ruby
module Speak
  def speak
    "Hello!"
  end
end

class Dog
  include Speak
end

class Human
  include Speak
end

my_dog = Dog.new
my_dog.speak # => "Hello!"
my = Human.new
me.speak # => "Hello!"
```

Method Lookup
-------------

Ruby has a distinct path it follows each time a method is called. As shown in the example below, after first looking for a method in the calling object's class, it next looks within any mixed-in modules, and then within an object's superclass. Note that Ruby actually starts looking at the last included module and works up from there.

```ruby
module Swimmable
end

module Climbable
end

class Animal
end

class Dog < Animal
  include Swimmable
end

p Dog.ancestors # => [Dog, Climbable, Swimmable, Animal, Object, Kernel, BasicObject]
```

Collaborator Objects
--------------------

Instance variables can be set to any object, even that of a custom class. In the example below, we've set the `@pet` instance variable to `fitz`, which is a `Dog` object. When we call `me.pet`, it returns a `Dog` object.

Working with collaborator objects in your class is no different than working with strings or integers or arrays.

```ruby
class Dog
  def initialize(name)
    @name = name
  end
end

class Person
  attr_accessor :name, :pet

  def initialize(name)
    @name = name
  end
end

me = Person.new("Nitin")
fitz = Dog.new("Fitz")

me.pet = fitz
```

Fake Operators
--------------

A primary aim of Ruby is to be very concise and succinct. The idea is that this allows programmers to concentrate more on the actual problem they're trying to solve. To meet this aim, the language contains a lot of "syntactical sugar", or special syntax that creates more natural language while hiding what's actually going on underneath. For example, instead of calling the equality method normally (eg. str1.==(str2)), we can call it with a special syntax that reads more naturally (eg. str1 == str2). A consequence of this syntactical sugar is that it's difficult to tell if a Ruby operator is actually a method being invoked with special syntax, or a "fake operator".

#### Fake Operators

| **Method**              | **Description**                       |
| ----------------        | -------------                         |
| `[]`, `[]=`             | Collection getter/setter              |
| `**`                    | Exponential operator                  |
| `!`, `~`                | Not, complement                       |
| `+`, `-`, `%`, `*`, `/` | Plus, minus, modulo, multiply, divide |
| `<<`, `<<`              | Right and left shift                  |
| `<`, `<=`, `>`, `>=`    | Less than, greater than, or equal to  |
| '<=>', `==`, `!=`, `=~` | Equality and pattern matching         |

#### Real Operators

| **Operator**                                  | **Description**               |
| ----------------                              | -------------                 |
| `&&`                                          | Logical "and"                 |
| <code>&#124;&#124;</code>                     | Logical "or"                  |
| `..`, `...`                                   | Inclusive and exclusive range |
| `? :`                                         | Ternary if-then-else          |
| `=`, `+=`, `-=`, `%=`, `*=`, `/=`, `%=`, `%=` | Assignment (and shortcuts)    |

A "fake operator" is actually a method and its functionality can be overridden in a custom class.

```ruby
class Dog
  attr_reader :age

  def initialize(name, age)
    @name = name
    @age = age
  end

  def >(other_dog)
    age > other_dog.age
  end
end

my_dog = Dog.new("Fitz", 2)
your_dog = Dog.new("Freddy", 6)

puts "Your dog is older." if your_dog > my_dog # => outputs "Your dog is older"
puts "My dog is older." if my_dog > your_dog # => no output
```

Let's look at the `[]` and `[]=` methods. The two groups of code below are equivalent. The second example simply reads more naturally by taking advantage of Ruby's syntactical sugar, making the methods appear as operators.

```ruby
array = ["Fitz", "Freddy"]

array[1] # => "Freddy"
array[2] = "Titan" # => "Titan"
array # => ["Fitz", "Freddy", "Titan"]
```

```ruby
array = ["Fitz", "Freddy"]

array.[](1) # => "Freddy"
array.[]=(2, "Titan") # => "Titan"
array # => ["Fitz", "Freddy", "Titan"]
```

Variable Scope
--------------
