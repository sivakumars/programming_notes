149 Study Guide
=================

Notes created while preparing for Assessment 149. This assessment is designed to test knowledge of courses 120 and 130 and will mainly focus on Object Oriented Programming concepts, though all prior material is fair game as well.

Classes and Objects
--------------------

Historically, a program has been viewed as a procedure that takes input data, processes it with step-by-step instructions, and provides output data. This is referred to as procedural programming.

**Object Oriented Programming** is a paradigm that was created to deal with the growing complexity of large programs. Programmers needed a way to change a piece of a large program without unexpectedly affecting the entire program.

OOP addresses this concern by using containers to group related attributes (or data) and behavior (or instructions). The container is called an object and the class is the outline of the possible attributes (properties) and behaviors (methods) of that object.

In Ruby, everything is an object. Strings, Arrays, Hashes, and Integers are all types of objects. And the properties and methods available to each of these object types is outlined in their class.

The workflow of creating a new object is called **instantiation**. In the example below, an instance of the Dog class was created and stored in the variable `my_dog`.

```ruby
class Dog
end

my_dog = Dog.new
```

Let's modify the class by adding an `initialize` method. If defined, the `initialize` method is called every time you create a new object. This type of method is known as a constructor.

```ruby
class Dog
  def initialize
    puts "You created a new Dog!"
  end
end

my_dog = Dog.new # => "You created a new Dog!"
```

Instance Methods and Instance Variables
---------------------------------------

Let's add behavior to the class. The Dog class now has a `bark` method that can be called on any Dog object. We define these behaviors as instance methods in a class.

```ruby
class Dog
  def bark
    puts "Woof!"
  end
end

my_dog = Dog.new
my_dog.bark # => outputs "Woof!"
```

Let's add an attribute to the class. The Dog class now has a `name` attribute. In addition, there are a couple new instance methods that allow an object to assign (`set_name`) and retrieve (`get_name`) the name of a Dog object. In addition to `name`, we can allow the object to track other information about a Dog object, like age or weight. In a class, we use instance variables (`@`) to track information about the state of an object. The variable exists as long as the object instance exists.

```ruby
class Dog
  def set_name=(name)
    @name = name
  end

  def get_name
    @name
  end
end

my_dog = Dog.new
my_dog.set_name("Fitz")
my_dog.get_name # => returns "Fitz"
```

Accessor Methods
----------------

The two methods added in the previous example are known as accessor methods.  More specifically, `set_name` is a `setter` method and `get_name` is a `getter` method. Because these methods are so common, Ruby has a built-in way to automatically create them for us, using the **attr_accessor** method. The example code below is practically equivalent to the previous example.

```ruby
class Dog
  attr_accessor :name
end

my_dog = Dog.new
my_dog.name = "Fitz"
my_dog.name # => returns "Fitz"
```

If we only want a `getter` method, we can use `attr_reader` instead, and if we only want a `setter` method, we can use `attr_writer`.

Self
----

In the example below, a Dog is adopted by a new owner, and we expect the value of the `owner` instance variable to be updated. But it doesn't work!

```ruby
class Dog
  attr_accessor :name, :owner

  def initialize(name, owner = "none")
    @name = name
    @owner = owner
  end

  def adopted_by(name)
    owner = name
  end
end

my_dog = Dog.new("Fitz")
my_dog.adopted_by("Carlos")
my_dog.owner # => "none"
```

This is because Ruby thinks we're trying to create a local variable, `owner`, a consequence of our expectations of Ruby's syntactical sugar. To clarify what we want and call the setter method, we must use `self`.

```ruby
class Dog
  attr_accessor :name, :owner

  def initialize(name, owner = "none")
    @name = name
    @owner = owner
  end

  def adopted_by(name)
    self.owner = name
  end
end

my_dog = Dog.new("Fitz")
my_dog.adopted_by("Carlos")
my_dog.owner # => "Carlos"
```

When `self` is called from within an instance method, it refers to the calling object, in this case, the `my_dog` object. So calling `self.owner` is the same as calling `my_dog.owner`

Another use of self involves class methods. Class methods are used for functionality that doesn't pertain to an individual object. A class method is called directly on the class itself, and it is defined by prepending the method name with `self`.

```ruby
class Dog
  def self.what_am_i
    puts "I'm a Dog class."
  end
end

Dog.what_am_i # => outputs "I'm a Dog class."
```

When `self` is called inside a class but outside an instance method, it refers to the class itself. So, `def self.method` is the same as `def Dog.method`.

Private, Protected, and Public
-------------------------------

A **public method** is accessible to anyone who knows either the class name or the object's name. These methods comprise the class's *interface*, or how other classes and objects can interact with this class and its objects.

Both **private methods** and **protected methods** are only accessible from other methods in the class.

The difference is that a **private method** can only be called from within the calling object. It cannot access another object's private methods directly, and you can't use `self`.

Inheritance
-----------

Inheritance is when a class inherits behavior from another class. In the example below, `Dog` subclasses `Animal` and inherits all of its methods. Therefore, the `my_dog` object is able to call the `speak` method.

```ruby
class Animal
  def speak
    "Hello!"
  end
end

class Dog < Animal
end

my_dog = Dog.new
my_dog.speak # => outputs "Hello!"
```

In the example below, the `Dog` class overrides the `speak` method from the `Animal` class because Ruby checks the object's class first before looking in the superclass.

```ruby
class Animal
  def speak
    "Hello!"
  end
end

class Dog < Animal
  def speak
    "Woof!"
  end
end

my_dog = Dog.new
my_dog.speak # => "Woof!"
```

Super
------

Ruby provides a built-in function called `super` that allows us to call methods up the inheritance hierarchy. When you call `super`, it will search the hierarchy for a method of the same name and invoke it.

```ruby
class Animal
  def speak
    "Hello!"
  end
end

class Dog < Animal
  def speak
    super + " Woof!"
  end
end

my_dog = Dog.new
my_dog.speak # => "Hello! Woof!"
```

A common way of using `super` is with `initialize`. In this example, the `name` argument is passed to the superclass, which sets it to the `@name` instance variable.

```ruby
class Animal
  def initialize(name)
    @name = name
  end
end

class Dog < Animal
  def initialize(name, color)
    super(name)
    @color = color
  end
end

my_dog = Dog.new("Fitz", "Brown")
```

Module Mix-in
-------------

Like classes, modules contain shared behavior. But you cannot instantiate an object with a module. To use a module's methods, it must be "mixed in" to a class using `include`. In the example below, both `Dog` and `Human` have access to the `speak` instance method.

```ruby
module Speak
  def speak
    "Hello!"
  end
end

class Dog
  include Speak
end

class Human
  include Speak
end

my_dog = Dog.new
my_dog.speak # => "Hello!"
my = Human.new
me.speak # => "Hello!"
```

Method Lookup
-------------

Ruby has a distinct path it follows each time a method is called. As shown in the example below, after first looking for a method in the calling object's class, it next looks within any mixed-in modules, and then within an object's superclass. Note that Ruby actually starts looking at the last included module and works up from there.

```ruby
module Swimmable
end

module Climbable
end

class Animal
end

class Dog < Animal
  include Swimmable
end

p Dog.ancestors # => [Dog, Climbable, Swimmable, Animal, Object, Kernel, BasicObject]
```

Collaborator Objects
--------------------

Instance variables can be set to any object, even that of a custom class. In the example below, we've set the `@pet` instance variable to `fitz`, which is a `Dog` object. When we call `me.pet`, it returns a `Dog` object.

Working with collaborator objects in your class is no different than working with strings or integers or arrays.

```ruby
class Dog
  def initialize(name)
    @name = name
  end
end

class Person
  attr_accessor :name, :pet

  def initialize(name)
    @name = name
  end
end

me = Person.new("Nitin")
fitz = Dog.new("Fitz")

me.pet = fitz
```

Fake Operators
--------------

A primary aim of Ruby is to be very concise and succinct. The idea is that this allows programmers to concentrate more on the actual problem they're trying to solve. To meet this aim, the language contains a lot of "syntactical sugar", or special syntax that creates more natural language while hiding what's actually going on underneath. For example, instead of calling the equality method normally (eg. str1.==(str2)), we can call it with a special syntax that reads more naturally (eg. str1 == str2). A consequence of this syntactical sugar is that it's difficult to tell if a Ruby operator is actually a method being invoked with special syntax, or a "fake operator".

#### Real Operators

| **Operator**                                  | **Description**               |
| ----------------                              | -------------                 |
| `&&`                                          | Logical "and"                 |
| <code>&#124;&#124;</code>                     | Logical "or"                  |
| `..`, `...`                                   | Inclusive and exclusive range |
| `? :`                                         | Ternary if-then-else          |
| `=`, `+=`, `-=`, `%=`, `*=`, `/=`, `%=`, `%=` | Assignment (and shortcuts)    |

#### Fake Operators

| **Method**              | **Description**                       |
| ----------------        | -------------                         |
| `[]`, `[]=`             | Collection getter/setter              |
| `**`                    | Exponential operator                  |
| `!`, `~`                | Not, complement                       |
| `+`, `-`, `%`, `*`, `/` | Plus, minus, modulo, multiply, divide |
| `<<`, `<<`              | Right and left shift                  |
| `<`, `<=`, `>`, `>=`    | Less than, greater than, or equal to  |
| '<=>', `==`, `!=`, `=~` | Equality and pattern matching         |


A "fake operator" is actually a method and its functionality can be overridden in a custom class.

```ruby
class Dog
  attr_reader :age

  def initialize(name, age)
    @name = name
    @age = age
  end

  def >(other_dog)
    age > other_dog.age
  end
end

my_dog = Dog.new("Fitz", 2)
your_dog = Dog.new("Freddy", 6)

puts "Your dog is older." if your_dog > my_dog # => outputs "Your dog is older"
puts "My dog is older." if my_dog > your_dog # => no output
```

Let's look at the `[]` and `[]=` methods. The two groups of code below are equivalent. The second example simply reads more naturally by taking advantage of Ruby's syntactical sugar, making the methods appear as operators.

```ruby
array = ["Fitz", "Freddy"]

array[1] # => "Freddy"
array[2] = "Titan" # => "Titan"
array # => ["Fitz", "Freddy", "Titan"]
```

```ruby
array = ["Fitz", "Freddy"]

array.[](1) # => "Freddy"
array.[]=(2, "Titan") # => "Titan"
array # => ["Fitz", "Freddy", "Titan"]
```

Instance Variable Scope
-----------------------

Instance variables start with `@` and are scoped at the object level. Unlike local variables, the instance variable is accessible in any instance method, even if it's initialized outside that instance method.

```ruby
class Dog
  def initialize(name)
    @name = name
  end

  def get_name
    @name
  end
end

my_dog = Dog.new("Fitz")
my_dog.get_name # => "Fitz"
```

Also unlike local variables, if you access an instance variable that has not been initialized, `nil` is returned. With a local variable, a `NameError` would be raised.

```ruby
class Dog
  def get_name
    @name
  end
end

my_dog = Dog.new
my_dog.get_name # => nil
```

What about inheritance? In the example below, it appears as if the Dog class doesn't have access to the `@name` instance variable. But upon closer inspection, it does. Dog subclasses `Animal`, therefore when a `Dog` object is instantiated, it looks for an `initialize` method. Since it doesn't find one in the `Dog` class, it proceeds up the method lookup path and finds an `initialize` method in the `Animal` class. The `@name` instance variable is initialized and belongs to the `Dog` object.

```ruby
class Animal
  def initialize(name)
    @name = name
  end
end

class Dog < Animal
  def to_s
    "Woof! My name is #{@name}."
  end
end

my_dog = Dog.new("Fitz")
puts my_dog.to_s # => "Woof! My name is Fitz."
```

Class Variable Scope
-----------------------

Class variables start with `@@` and are scoped at the class level. All objects of a class share 1 copy of the class variable. And class methods can access class variables, regardless of where it's initialized. Only class variables can share state between objects.

```ruby
class Dog
  @total_dogs = 0

  def initialize
    @@total_dogs += 1
  end

  def total_dogs
    @@total_dogs
  end
end

Dog.total_dogs # => 0
my_dog = Dog.new
Dog.total_dogs # => 1
your_dog = Dog.new
Dog.total_dogs # => 2
```

With inheritance, it's possible for a class variable in a subclass to afefct the class variable in a superclass. For this reason, avoid class variables when working with inheritance. Some Rubyists even recommend avoiding class variables altogether.

Constant Variable Scope
-----------------------

Constants begin with a capital letter and have lexical scope. Unlike class or instance variables, constants can be accessed from completely separate classes.

```ruby
class Dog
  LEGS = 4
end

class Human
  LEGS = 2

  def legs
    "I have #{LEGS} legs and my dog has #{Dog::LEGS} legs."
  end
end

me = Human.new
me.legs # => "I have 2 legs and my dog has 4 legs."
```

Let's look at inheritance. As expected, a constant initialized in a superclass is inherited by the subclass, and can be accessed by both class and instance methods. When using modules, however, we need to be explicit about where a constant is located.

```ruby
module Legs
  def legs
    "I have #{Dog::LEGS} legs"
  end
end

class Dog
  include Legs

  LEGS = 4
end

my_dog = Dog.new
my_dog.legs # => "I have 4 legs."
```

Closures
--------

A closure is a concept that allows programmers to save a "chunk of code" and execute it at a later time. In addition to saving the "chunk of code", a closure binds its surrounding variables, methods, and objects so they can be referenced when the closure is later executed. In Ruby, closures are implemented with blocks, `Proc` objects, and lambdas.

### Blocks

A block is often passed as an argument to a method call. In the example below, the block is the code in between the `do ... end`.

```ruby
[1, 2, 3].select do |num|
  num.odd?
end
# => [1, 3]
```

In Ruby, every method can take an optional block as an implicit parameter. It's up to the method implementation to decide what to do with the block of code given to it. Most methods just ignore the block.

```ruby
puts("hello") { " goodbye!" } # => outputs "hello"
```

The `yield` keyword allows a method to use the code passed in with the block

```ruby
def print_block(arg1)
  puts arg1 + yield
end

print_block("hello") { " goodbye!" } # => outputs "hello goodbye!"

print_block("hello") # => LocalJumpError: no block given (yield)
```

If a method expects but isn't passed a block, it will raise a `LocalJumpError`. To make the block optional, the `Kernel#block_given?` method can be used.

```ruby
def print_block(arg1)
  puts(block_given? ? arg1 + yield : arg1)
end

print_block("hello") { " goodbye!" } # => outputs "hello goodbye!"
print_block("hello") # => outputs "hello"
```

In addition, a block can be passed arguments of its own when it's yielded to by a method. In the example below, when the block is called, `number + 1` is passed to the block and its value is assigned to the block local variable `num`.

```ruby
def increment(number)
  block_given? ? yield(number + 1) : (number + 1)
end

increment(5) # => 6

increment(5) do |num|
  num + 1
end # => 7
```

Once again, calling a block is like calling a method. Unlike a method, however, blocks have lenient arity rules. **Arity** refers to the rules around enforcing the number of arguments you can call on a method or closure. `Proc` objects and `lambda`s have different arity rules from blocks.

There are two main use cases for blocks:

1. Give the method caller more power and flexibility when invoking a method.

```ruby
[1, 2, 3].select do |num|
  num.odd?
end
# => [1, 3]
```

2. Sandwich code â€” when a method implementor wants to allow a method caller to do something before and after an action but doesn't care what that action is. The code in the block becomes that action.  

```ruby
File.open("some_file.txt", "w+") do |file|
  # write to this file using file.write
end
```

### Procs

A block may also be explicitly passed into a method. When this occurs, the `&block` parameter converts the passed in block into a `Proc` object that is then assigned to local variable `block`.

```ruby
def increment(&block)
  block
end

increment { "stored in block" } # => #<Proc:0x007fc6b7005fc0@(irb):15>
```

Whenever a method contains a parameter prepended with `&`, it saves the block as a `Proc` object into a local variable, and that `Proc` can be executed with the `call` method or passed into another method.

A `Proc` is an object that contains a block. As an object, a `Proc` has more flexibility to be passed around and called. As an object, a `Proc` can be directly passed into a method.

```ruby
a = Proc.new { "stored in proc"}

def increment(proc1)
  proc1
end

increment(a) # => #<Proc:0x007fc6b7aa6768@(irb):23>
```

Multiple `Proc` objects can be passed into a method in this way, while at most one block can appear in an argument list.

### Lambdas

```ruby
proc = Proc.new { "block"}
lam = lambda { "block" }

proc # => #<Proc:0x007fc6b7a8eed8@(irb):30>
lam # => #<Proc:0x007fc6b80a67a8@(irb):31 (lambda)>
```

A `lambda` is a type of `Proc` object. There are a few key differences though.

1. Different arity. Lambdas validate the number of arguments, procs do not.
2. They treat the `return` keyword differently.

```ruby
def lambda_test
  lam = lambda { return }
  lam.call
  puts "Hello!"
end

def proc_test
  proc = Proc.new { return }
  proc.call
  puts "Hello!"
end

lambda_test # => outputs "Hello!"
proc_test # => outputs nothing
```

Inside a `lambda`, a `return` jumps back to the code right after the lambda was called. Inside a `Proc`, a `return` jumps outside the method where the `Proc` was called.

```ruby
def call_me(some_code)
  some_code.call
end

name = "Robert"
chunk_of_code = Proc.new {puts "hi #{name}"}
name = nil

call_me(chunk_of_code)
```

Collection methods that take a block
-------------------------------------

```ruby
def each(array)
  counter = 0
  while counter < array.size
    yield(array[counter])
    counter += 1
  end
  array
end

each([1, 2, 3]) do |num|
  p num
end # => outputs each num on separate lines and returns [1, 2, 3]
```

```ruby
def select(array)
  counter = 0
  new_array = []
  while counter < array.size
    current_element = array[counter]
    new_array << current_element if yield(current_element)
    counter += 1
  end
  new_array
end

select([1, 2, 3]) do |num|
  num.odd?
end # => [1, 3]
```

```ruby
def map(array)
  counter = 0
  new_array = []
  while counter < array.size
    new_array << yield(array[counter])
    counter += 1
  end
  new_array
end

map([1, 2, 3]) do |num|
  num + 1
end # => [2, 3, 4]
```

```ruby
def reduce(array, default=0)
  counter = 0
  result = default
  while counter < array.size
    result = yield(result, array[counter])
    counter += 1
  end
  result
end

reduce([1, 2, 3]) do |acc, num|
  acc + num
end # => 6
```
