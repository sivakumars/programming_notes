189 Study Guide
=================

Notes created while preparing for Assessment 189. This assessment is designed to test knowledge of course 180 and will focus on Databases, SQL, PostgreSQL, and Sequel.

Introduction
------------

Human beings use their brains to remember things that happened in the past and make decisions for the future. Because their brains have limited capacity, humans record information on paper or a computer. This information is called **data**. When the amount of data grows too large for a human to  analyze it, it's stored in a **database** so a computer, guided by a human, can analyze it.

Most data, for example, the content of a text message, is unstructured. A text message comes with additional data though. Each text has the sender's phone number, the receiver's phone number, and the date and time the text was sent. This data is structured.

A **relational database** is a database that organizes and stores structured data into tables of columns and rows. Tables are also called relations or entities. Rows are also called records or tuples. Columns are also called attributes or fields.

| phone_number | name    |
|--------------|---------|
| 123-456-7890 | "Bob"   |
| 987-654-3210 | "Nitin" |
| 612-612-6120 | "Carlos"|

A relational database management system (RDBMS) is an application that allows a user to access a database to record, organize, and retrieve data. Well-known DBMSs include MySQL, PostgreSQL, MongoDB, Microsoft SQL Server, Oracle, and IBM DB2. The term "database" is often used interchangeably to describe an RDBMS, and **SQL** (Structured Query Language) is *special purpose language* that is used to interact with a RDBMS.

SQL is really three languages in one, containing smaller sub-languages for data definition, data manipulation, and data control.

The **data definition** sub-language allows a user to create and modify the database schema. The **data manipulation** sub-language allows a user to retrieve and modify data stored in a database. The **data control** sub-language allows a user to control the rights and access roles of the users that interact with a database or table.

A database's structure is described in what's called a **schema**. In addition to column names, the schema indicates what data is allowed in a particular column. For example, the `name` column should only allow text. This restriction is called a column's **data type**. A **constraint** makes it possible to further restrict possible values of a column, for example, ensuring that all values in a column are unique or that all values are positive.

While the schema describes the structure of the database, the **data** is the actual content that exists within that structure, like "Bob" and "Nitin" in the example table above.

Primary Keys
--------------

A **key** uniquely identifies a single row in a database table. A **natural key** is an attribute of the data that can be used to uniquely identify a row of data, for example, the `phone_number` column in the Contacts table. Since a natural key can often change, however, it's preferred to use a **surrogate key**, which is created solely for the purpose of identifying a row of data in a table.

A surrogate key is commonly configured to be an *auto-incrementing integer* that begins at 1 and increases by 1 with each new row. PostgreSQL contains a keyword, `serial`, that automatically configures a surrogate key column when creating a table.

```SQL
CREATE TABLE table_name (
  id serial
);

CREATE TABLE table_name (
  id integer NOT NULL DEFAULT nextval('table_name_id_seq')
);
```

The two SQL statements above are equivalent. As part of this configuration, a **sequence** is created. A sequence is simply a special table that generates a series of numbers. In the expanded SQL statement above, the `table_name_id_seq` is passed as an argument to the `nextval` function which is assigned as the `DEFAULT` value of the `id` column when inserting a new row into the table.

The last step is to ensure that all values of the `id` column are unique by adding a constraint to the column.

```SQL
CREATE TABLE table_name (
  id serial UNIQUE
);

CREATE TABLE table_name (
  id serial PRIMARY KEY
);
```

PostgreSQL has another keyword, `PRIMARY KEY` that enforces uniqueness by creating an UNIQUE CONSTRAINT index on the column. It's an accepted convention in Web Development to create a **primary key** column named `id` in all database tables. A primary key is a column that uniquely identifies a row in a table.

An **index** is a mechanism to speed up data retrieval by storing results in a separate table-like structure in ordered form. Every time a row is inserted into an indexed column, the index must be updated. Therefore, while indexes increase the speed of data retrieval, they can decrease the speed of data inserts and updates. Indexes are best used in tables where reads are more common.

Foreign Keys
-------------

Databases can reduce redundancy by splitting a table into multiple tables. **Normalization** is the process of designing schema that minimize the possible occurrences of update, insertion, and deletion anomalies. The basic procedure involves extracting data into additional tables as demonstrated below.

## Denormalized Table of Text Messages

| id | sender_phone | sender_name | receiver_phone | receiver_name | content      |
|----|--------------|-------------|:--------------:|---------------|--------------|
| 1  | 123-456-7890 | "Bob"       |  987-654-3210  | "Nitin"       | "Hello"      |
| 2  | 987-654-3210 | "Nitin"     |  123-456-7890  | "Bob"         | "Hey"        |
| 3  | 987-654-3210 | "Nitin"     |  123-456-7890  | "Bob"         | "What's Up?" |

## Texts

| id | sender_id | receiver_id| content        |
|----|-----------|:----------:|----------------|
| 1  | 1         |  2         | "Hello"        |
| 2  | 2         |  1         | "Hey"          |
| 3  | 2         |  1         | "What's up?"   |
| 4  |           |  2         | "Who is this?" |

## Contacts

| id | phone_number | name    |
|----|--------------|---------|
| 1  | 123-456-7890 | "Bob"   |
| 2  | 987-654-3210 | "Nitin" |
| 3  | 612-612-6120 | "Carlos"|

A **foreign key** is a column that uses another table's primary key value to point to a specific row in that table. In this manner, it creates a relationship between two rows belonging to two different tables. The Texts table has a `sender_id` column that contains values that point to a corresponding row in the Contacts table. Specifically, it points to values in the `phone_number` column, the Contacts table's primary key column. The similar relationship exists with the `receiver_id` column, indicating that there are two foreign keys in the Texts table.

A **foreign key constraint** enforces certain rules about what values are permitted in a foreign key column. There are two ways to create this constraint.

```SQL
CREATE TABLE table_name (
  id serial PRIMARY KEY,
  contact_id integer REFERENCES contacts(id)
  name varchar(255)
);

ALTER TABLE table_NAME ADD CONSTRAINT table_name_contact_fkey FOREIGN KEY (contact_id) REFERENCES contacts(id);
```

A foreign key constraint ensures that all values in a foreign key column also exist in the primary key column of the referenced table.

JOIN Clause
-----------

A **JOIN** is a SQL clause that returns rows from two different tables based on a common column between them. There are several slightly different types of JOINs.

An **INNER JOIN** returns the rows for which the common column had a matching value.
`SELECT * FROM texts JOIN contacts ON sender_phone = phone_number;`

| id | sender_phone | receiver_phone | content        | name    | phone_number |
|----|--------------|:--------------:|----------------|---------|--------------|
| 1  | 123-456-7890 |  987-654-3210  | "Hello"        | "Bob"   | 123-456-7890 |
| 2  | 987-654-3210 |  123-456-7890  | "Hey"          | "Nitin" | 987-654-3210 |
| 3  | 987-654-3210 |  123-456-7890  | "What's up?"   | "Nitin" | 987-654-3210 |

Note that the JOIN table only contains the 3 rows that matched.

A **LEFT OUTER JOIN** takes all the rows from the first (or left) table and JOINs it with a second (or right) table. A LEFT JOIN will always include all of the rows from the original left table, even if there were no matches in the right table.

`SELECT * FROM contacts LEFT JOIN texts ON phone_number = sender_phone;`

| id | sender_phone | receiver_phone | content        | name    | phone_number |
|----|--------------|:--------------:|----------------|---------|--------------|
| 1  | 123-456-7890 |  987-654-3210  | "Hello"        | "Bob"   | 123-456-7890 |
| 2  | 987-654-3210 |  123-456-7890  | "Hey"          | "Nitin" | 123-456-7890 |
| 3  | 987-654-3210 |  123-456-7890  | "What's up?"   | "Nitin" | 123-456-7890 |
| 3  | 987-654-3210 |  111-111-1111  | "Who is this?" |         | 111-111-1111 |

Note that the JOIN table contains 4 rows even though there was no matching `name` found for 111-111-1111.

A **RIGHT OUTER JOIN** is similar to a LEFT OUTER JOIN except it includes all rows from the second table, regardless of if there were matches or not.

| id | sender_phone | receiver_phone | content        | name    | phone_number |
|----|--------------|:--------------:|----------------|---------|--------------|
| 1  | 123-456-7890 |  987-654-3210  | "Hello"        | "Bob"   | 123-456-7890 |
| 2  | 987-654-3210 |  123-456-7890  | "Hey"          | "Nitin" | 987-654-3210 |
| 3  | 987-654-3210 |  123-456-7890  | "What's up?"   | "Nitin" | 987-654-3210 |
|    |              |                |                | "Carlos"| 612-612-6120 |

Note that the JOIN table again contains 4 rows even though there were no texts sent by "Carlos".

Database Relationships
-------------------

There are 3 types of table relationships in a relational database.
- One-to-One --> PRIMARY KEY of 1st table is used as both FOREIGN KEY and PRIMARY KEY of 2nd table
- One-to-Many --> PRIMARY KEY of 1st table is used as FOREIGN KEY of 2nd table
- Many-to-Many --> 3rd cross-reference table contains relationship between two other tables and contains composite PRIMARY KEY containing the PRIMARY KEY of each of the other two tables

**Cardinality** is the number of objects on each side of the relationship. The cardinality can be either "one" or "many". The **modality** of a relationship indicates if that relationship is required (1) or optional (0).

SELECT Execution Steps
----------------------

1) Rows are collected into a virtual table
2) Rows are filtered using `WHERE` conditions. Any rows that don't satisfy the conditions are removed.
3) Rows are divided into appropriate groups based on `GROUP BY` columns.
4) Groups (of rows) are filtered using `HAVING` conditions.
5) Elements in the `SELECT` list are evaluated, including functions, and the results are labeled with the column name or function name unless otherwise specified by an `AS` clause.
6) The results are sorted as indicated by an `ORDER BY` clause.
7) The actual rows returned are determined using `LIMIT` or `OFFSET` clauses.

Sequel
------

Sequel is a database interface library / toolkit / API that allows SQL queries to be represented as Ruby objects.

A Sequel::Database object represents a virtual connection to a database. A Sequel::Dataset object represents a SQL query, or more generally, an abstract set of rows in the database.

```ruby
require "sequel"

DB = Sequel.connect('postgres://localhost/db_name') # creates Sequel::Database object

results = DB[:table_name] # creates Sequel::Dataset object with "SELECT * FROM table_name"
```

A Dataset instance does not always immediately run its query. It will wait until the results of the query are needed. For example, while an `UPDATE` or `INSERT` query will run immediately, a `SELECT` queries isn't run until the results of the query are requested using an instance method like `all`, `first`, or `count`.

As mentioned, a Dataset represents an abstract set of rows and each row is represented as a hash. Therefore, `results.all` will return an array of hashes and `results.first` will return a hash representing the first row of results. In addition, Dataset implements Ruby's Enumerable module, so Ruby methods like `each` and `map` will all work as expected.

SQL Queries in Sequel
---------------------

`CREATE TABLE table_name (col_name col_type options,...);`

```ruby
create_table(:table_name) do
  primary_key :id
  String :name, unique: true
  Integer :age, null: false, default: 0
  Numeric :cost, size: [4,2]
  Float :height
  Boolean :adult
  check{char_length(name) > 2}
end
```

`INSERT INTO table_name (col_name,...) VALUES (col_value,...);`

```ruby
DB[:table_name].insert(name: "Nitin", age: 30, height: 76.0, adult: true)
```

`SELECT col_names FROM table_name WHERE col_name = col_value ORDER BY col_name DESC;`

```ruby
DB[:table_name].select(:col_name,...).where(col_name: col_value).order(:col_name).reverse
DB[:table_name].select(:col_name,...).where(col_name: col_value).order(Sequel.desc(:col_name))
```

`SELECT * FROM table_name WHERE col_name LIKE '%string%';`

```ruby
DB[:table_name].where(Sequel.like(:col_name, '%string%'))
```

`UPDATE table_name SET col_name = col_value WHERE col_name = col_value;`

```ruby
DB[:table_name].update(col_name: col_value)
```

`DELETE FROM table_name WHERE col_name = col_value;`

```ruby
DB[:table_name].where(col_name: col_value).delete
```

`ALTER TABLE table_name ADD COLUMN col_name options;`

```ruby
DB.alter_table(:table_name) do
  add_column :cost, Numeric, null: false, size: [4,2]
end
```

`ALTER TABLE table_name DROP COLUMN col_name;`

```ruby
DB.alter_table(:table_name) do
  drop_column :cost
end
```

`ALTER TABLE table_name RENAME COLUMN col_name TO new_col_name;`

```ruby
alter_table(:table_name) do
  rename_column :col_name, :new_col_name
end
```

`ALTER TABLE table_name ALTER COLUMN col_name TYPE new_type;`

```ruby
alter_table(:table_name) do
  set_column_type :col_name, :String
end
```

`ALTER TABLE table_name ALTER COLUMN col_name SET NOT NULL DEFAULT 0;`

```ruby
alter_table(:table_name) do
  set_column_allow_null :col_name
  set_column_default :col_name, 0
end
```

`ALTER TABLE table_name ADD CHECK(col_name > 0);`

`ALTER TABLE table_name ADD CONSTRAINT constraint_name CHECK(length(col_name) > 2);`

```ruby
alter_table(:table_name) do
  add_constraint(:name_min_length){char_length(col_name) > 2}
end
```

`ALTER TABLE table_name DROP CONSTRAINT constraint_name;`

```ruby
alter_table(:table_name) do
  drop_constraint(:name_unique)
end
```

`ALTER TABLE table_name ADD UNIQUE(col_name);`

```ruby
alter_table(:table_name) do
  add_unique_constraint :name
end
```

`ALTER TABLE table_name RENAME TO new_table_name;`

```ruby
DB.rename_table(:table_name, :new_table_name)
```

`DROP TABLE table_name;`

```ruby
DB.drop_table(:table_name)
```

`CREATE SEQUENCE table_name_seq;`

`DROP SEQUENCE table_name_seq;`

`CREATE INDEX ON table_name (col_name);`

`DROP INDEX index_name`
