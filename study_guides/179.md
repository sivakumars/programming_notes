179 Study Guide
=================

Notes created while preparing for Assessment 179. This assessment is designed to test knowledge of course 170 and will focus on HTTP, the Web, and Sinatra.

Internet
---------

The Internet is a tangible, physical structure made to move information. Like the postal service, the Internet sends things from one place to another, but instead of letters and packages, it sends bits (or binary information). These bits are usually sent through either electricity (ethernet/copper cable), light (fiber optic cable), or radio (wireless transmission).

Ethernet cable is cheap but suffers from significant signal loss over long distances. Fiber optic is fast and doesn't suffer from much signal loss but is expensive. Wireless translates bits into radio waves of different frequencies but suffers from very significant signal loss. The physical methods for moving bits has and will continue to change, but the underlying binary representation of information and the protocols for sending and receiving that information have and will likely stay the same.

TCP/IP
-------

In addition to the physical structure, the Internet comprises of a design philosophy that is expressed in a set of protocols. A protocol is defined as an agreed-upon set of rules for sending and receiving information.

The first protocol helps a computer send information to another computer. Every Internet-connected computer has a unique address, analogous to a person's mailing address, and that address is used to determine where to send information. Let's say a user wants to use the Internet to view a website. To do this, the user's computer must send a message to the website's computer requesting the contents of the website. After entering the site URL, http://www.example.com/, into a web browser, the website request is first forwarded to the Domain Name System (DNS), which translates the human-friendly site (www.example.com) into the address of the website's computer, 90.32.123.122), called an IP address. With the IP address in hand, the browser knows where to send its message requesting the website. This system of assigning addresses to computers and routing information between computers based on these addresses comprise what's known as the Internet Protocol (IP).

Like a car, Internet information doesn't usually travel in a fixed or direct path. If there happens to be construction or traffic on a particular route, a faster route is selected. In addition, the entire message isn't sent at once; it's broken into tiny chunks called packets. Each packet is tagged with an IP header, which includes the source and destination IP addresses, and a TCP header, which includes the source and destination port numbers. Once broken up, the packets travel independently, optimizing their own routes, and are reassembled into the original message once all arriving successfully at the destination computer. This process of breaking up, sending, verifying, resending, and reassembling packets is called transmission control protocol (TCP).

Together, this system of communication is known as the **TCP/IP** suite.

When computers exchange messages, they're either sending a request for information or responding to a request for information; this is known as the "request-response" messaging pattern. The computer that requests information is called the "client" and the computer that returns a response is called the "server". The content of these messages is just text, and the language used is the hypertext transfer protocol (HTTP). HTTP is a set of rules outlining the specific information that a request or response must contain and the specific format that a request and response must follow.

To summarize the section: on the Internet, computers send HTTP messages, either requests or responses, over TCP/IP connections.

URL
----

When you a URL into a browser and hit ENTER, the TCP/IP protocol is used to send an HTTP message requesting a specific resource from a web server.

`URL: http://www.example.com:88/home?item=book`

The URL can be broken into 5 parts:

- `http`: The **scheme** always comes before the colon and two forward slashes and tells the browser how to access the resource.
- `www.example.com`: The **host** tells the browser where the resource is located on the Internet.
- `:88`: The **port** indicates which port on the web server to send the request.
- `/home/`: The **path** indicates the specific resource requested from the web server.
- `?item=book`: The **query string** is made up of **query parameters** and is used to send additional data to the server.

While query strings are an easy way to send additional information to a server, there are several limitations.

- They have a maximum length.
- The data is not secure and completely visible in the URL.
- Certain reserved characters (e.g. `%`, `/`, `?`, `:` `@`, `&`) must be encoded to be used in an URL.

HTTP
------

To issue an HTTP request, a method ("GET") and path ("/") are required.

```HTTP
GET / HTTP/1.1
```

To issue an HTTP response, a status code ("200 OK") is required.

```HTTP
HTTP/1.1 200 OK
```

In addition to the required components, an HTTP request or response may optionally contain headers and a body.

The HTTP header typically contains metadata and that metadata can differ for each request and response.

Common HTTP Request Headers:
- Content-Type
- Cookie
- Host
- User-Agent

Common HTTP Response Headers:
- Content-Type
- Location
- Content-Length
- Set-Cookie

The HTTP body contains the main content of the message. Depending on the nature of the request, it may be empty. An HTTP request body will sometimes contain form data submitted using a POST request. An HTTP response body will commonly contain raw HTML code representing a requested web page.

HTTP Methods
-------------

The **Request Method** is a request header that tells the web server what to do with the resource requested by the HTTP message. The two most common types of HTTP methods are **GET** and **POST**.

**GET** is used to retrieve a resource (e.g. web page) from the server. They are read-only, meaning nothing is modified on the server. GET requests respond with a "200 OK" if the resource was found and "404 NOT FOUND" if the resource couldn't be found.

If the HTTP response body contains HTML code that references additional resources, the browser will automatically issue a GET request for each of those resources.

**POST** is used to send or submit data (e.g. sign up a new user) to the server with the intent of changing data on the server. A POST request is used when submitting HTML form data to the server. When used with the HTTPS protocol, this allows a browser to ensure that the data is transmitted securely. Successful POST requests respond with a "201 Created" and a usually a `Location` header, which contains a redirect URL; the browser automatically issues a GET request to this URL.

Stateful Applications
---------------------

HTTP is a **stateless** protocol, meaning each request/response pair is completely independent of the previous one. This means that the server does not need to store information between requests. This quality makes HTTP a resilient protocol but developers must employ various tricks to build stateful web applications.

One trick is to use a **session** to store state during requests. The web server creates a **session identifier**, a unique token identifying the client, and sends it in a `set-cookie` response header. The browser stores `session id` as a cookie in local storage, and on subsequent requests, includes it as a `cookie` request header. When the server receives subsequent requests, it inspects the value of the `cookie` header, ensures that the `session id` is still valid, and retrieves any session-specific data to be included in the HTTP response body.

In between requests, the browser stores the `session id` in an HTTP cookie on your local computer.  If you close your browser and computer, the cookie is still there, at least until you clear your browser history and delete your cookies.

Another trick is through the use of `AJAX`, short for Asynchronous Javascript and XML. It allows browsers to send requests and process responses *without a full page refresh*. The responses from these requests are processed by what's called a callback. The callback is able to use client-side Javascript code to update the current page's HTML without actually refreshing the page.

Rack
-----
Rack is a Ruby interface that gives application developers a stable communications protocol between their application code and web servers. Rack helps alleviate the need to write and maintain lower level code related to working with different web servers.

To use Rack, an app must respond to a `call` method that takes an `env` hash as an argument and returns an array with 3 elements:
- HTTP status code (as a string)
- HTTP headers (as a set of key-value pairs inside a hash)
- HTTP response body (as an object that responds to `each`, usually `Array`)

```ruby
class HelloWorld
  def call(env)
    [
      '200',
      {'Content-Type' => 'text/plain'},
      ['Hello World']
    ]
  end
end
```

To run the app on the web server, the `rackup` command is used to run a rackup file (`config.ru`) that specifies the rack-based application.

```ruby
require_relative 'hello_world'

run HelloWorld.new
```

Sinatra and Ruby on Rails are web application frameworks that adhere to the Rack specification, make use of Rack's libraries, and are therefore categorized as "rack based" frameworks.

Sinatra
-------

Sinatra is a Ruby library (or framework) that makes it simple to write Ruby code that runs when a browser visits a particular URL. First we `require` `sinatra` and `sinatra/reloader`, which causes the app to reload its files every time we load a page, making development easier.

```ruby
require "sinatra"
require "sinatra/reloader"
```

The mapping of a URL pattern to some Ruby code is accomplished by defining a *route*.

```ruby
  get '/' do
    .. show something ..
  end
```

Each URL pattern is associated with a block of code that executes when the pattern is matched. Routes are matched in the order they are defined, and only the first match is executed. The value that is returned by the block is then sent to the browser.

Route patterns may include named parameters, accessible via the *params* hash:

```ruby
get '/hello/:name' do
  "Hello #{params['name']}!"
end
```

Routes may also utilize query parameters:

```ruby
get '/posts' do
  # matches "GET /posts?title=foo&author=bar"
  title = params['title']
  author = params['author']
end
```

The return value of a route block determines the response body passed to the web server and hence the browser.

Static files are served from the `./public` directory.

View templates are files that contain text that is converted to HTML before being sent to a browser in an HTTP response. In Sinatra, views are served from the `./views` directory. When matched, the route below renders `views/index.erb`.

```ruby
  get '/' do
    @title = "My Page"
    erb :index
  end
```

Any Ruby code can be placed in an .erb file by including it between `<%` and `%>`. If you want to display the return value, you use a special start tag, `<%=`.

```ruby
<h1><%= @title %></h1>
```

Templates take a second argument, the options hash:

```ruby
get '/' do
  erb :index, :layout => :layout
end
```

This will render `views/index.erb` embedded in the `views/layout.erb`.

Any code in a `before` filter is evaluated before each request and any code in an `after` filter is evaluated after each request. Instance variables set in `before` filters and routes are accessible by `after` filters:

```ruby
before do
  @note = 'Hi!'
end

after do
  puts @note
end
```

The top-level `helpers` method is used to define helper methods for use in route handlers and templates:

```ruby
helpers do
  def bar(name)
    "#{name}bar"
  end
end

get '/:name' do
  bar(params['name'])
end
```

A session is used to store state during requests. Enabling sessions provides one session hash per user session. The hash is stored as a cookie in the browser and included as a header in every HTTP request except the first request. The first request is when the server creates the session id and responds with a `set-cookie` header, instructing the browser to create and store a cookie.

The `configure` block is executed once at startup of the web server.

```ruby
configure do
  enable :sessions
end
```

You can add and remove values from the `session` hash within a Sinatra route, view, method, or view helper.

```ruby
get '/:value' do
  session['value'] = params['value']
end
```

It is possible to set the status code, headers, and body with the return value of the route block.

```ruby
get '/foo' do
  status 418
  headers \
    "Allow"   => "BREW, POST, GET, PROPFIND, WHEN",
    "Refresh" => "Refresh: 20; http://www.ietf.org/rfc/rfc2324.txt"
  body "I'm a tea pot!"
end
```

You can trigger a browser redirect with the `redirect` helper method. Using `redirect` interrupts the processing of a request and prevents any later code from executing.

```ruby
  get '/foo' do
    redirect '/bar'
  end
```

Security
--------

To prevent a hacker from trying to read your HTTP messages by *packet sniffing*, **HTTPS** is employed. When using HTTPS, every HTTP message is encrypted by **TLS** cryptographic protocol. TLS does two things: (1) uses certificates to communicate with remote servers and confirms the identity of the web server and (2) generates and exchange encryption keys with the browser to secure all HTTP requests and responses transmitted between two computers.

**Same-origin policy** is a concept that permits resources from the same site to access each other but prevents access to resources on different sites. The documents must have the same protocol, hostname, and port. The **cross-origin resource sharing (CORS)** policy relaxes this policy by allowing servers to use a header to explicitly list additional allowable hosts.

A `session id` is often employed to avoid the need for the user to re-authenticate (i.e. re-login) for every single request, as long as the it is included as a `Cookie` in a request header. **Session hijacking** is when a hacker somehow gets a hold of a user's `session id` and uses it to access the user's session and any access that user is granted on a website. To minimize this vulnerability, most sessions have an expiration date, after which the `session id` is no longer valid. Using HTTPS also reduces the change that a hacker can steal a `session id`.

**Cross-site scripting (XSS)** is an attack that can happen when a user is allowed to input HTML or Javascript in a web form. The solution to preventing this attack is to *escape* any values that come from an untrusted source. This involved replacing certain characters in the text with HTML entities that the browser won't interpret as code. The characters that must be escaped include quotes, greater or less than operators, and more. Sinatra provides the ability to automatically escape all output. Since this will automatically escape all `erb` return values, you must replace `<%=` with `<%==` where you want to disable auto-escaping.

```ruby
configure do
  set :erb, :escape_html => true
end
```
