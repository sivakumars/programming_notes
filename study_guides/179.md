179 Study Guide
=================

Notes created while preparing for Assessment 179. This assessment is designed to test knowledge of course 170 and will focus on HTTP, the Web, and Sinatra.

Internet
---------

The Internet is a tangible, physical structure made to move information. Like the postal service, the Internet sends things from one place to another, but instead of letters and packages, binary information (or bits) is sent. These bits are most often sent using electricity (ethernet cable), light (fiber optic cable), or radio (wireless transmission).

Ethernet (i.e. copper) cable is cheap but suffers from significant signal loss over long distances. Fiber optic is expensive but fast and doesn't suffer from significant signal loss; it's used under the oceans to connect continents. Wireless translates binary information into radio waves of different frequencies but suffers from significant signal loss. The physical methods for moving binary information has and will continue to change but the underlying binary representation of information and the protocols for sending and receiving that information will likely remain the same.

TCP/IP
-------

In addition to its underlying physical structure, the "Internet" describes a design philosophy expressed in a set of protocols. A protocol is an agreed-upon set of rules for sending and receiving information. Every computer on the Internet has a unique address (or IP address), analogous to a home's mailing address.

When a computer asks another computer for information, the requesting computer is called the "client" and the computer that receives and responds to the request is the "server".

The most common type of Client-Server request is a web page request. When a URL (e.g. http://www.example.com/) is typed into the browser to request a web page, the Domain Name System (DNS) is used to translate the human-friendly domain name (i.e. www.example.com) into a machine-friendly IP address (e.g. 90.32.123.122). A browser â€” or specifically, a browser's Internet Service Provider (ISP) - communicates with the DNS to obtain the proper IP address. The browser uses the translated IP address and establishes a connection with the web server.

With that connection established, a request now has what it needs to move from source to destination. But the information doesn't move in a fixed or direct path. Like a car, if there is construction or traffic on a particular route, the information takes a different faster route. The information also isn't sent at once; it's broken up into tiny chunks called packets. Each packet is tagged with a TCP header, which includes the source and destination port numbers, and an IP header, which includes the source and destination IP addresses. The packets are transmitted independently and reassembled at the destination into the original HTTP request.

The system of breaking, sending, resending, and reassembling packets (the transmission control protocol or TCP) and the routing of packets to the correct IP addresses together comprise what is known as TCP/IP.

HTTP
-----

With TCP/IP connections, computers can send and receive information to other computers, and the information they send is simply text (i.e. a string). This text is sent using a TCP/IP connection but also contains very specific information structured in a specific format. The agreement on how to format these text messages is known as the Hypertext Transfer Protocol (HTTP). In summary, HTTP messages are sent using TCP/IP connections between computers.

The required components of an HTTP request are the HTTP method and path. Parameters, headers, and body are optional. While the host (and port if there is one) is used to connect to the server and therefore is required to make an HTTP request, only the URL's path and parameters are included in the actual request. The required component of an HTTP response is the status code. Headers and body are optional.

An HTTP message can contain two parts: a header and a body. HTTP requests generally contain only an HTTP header. HTTP responses usually contain a header and a body, which contains the requested resource (e.g. web page).

The purpose of an HTTP header is for metadata (data about data). Headers are colon-separated name-value pairs that are sent in plain text. Here are the most important HTTP request headers.

- Request Method
- Content-Type
- Cookie
- Host
- User-Agent

And are the most important HTTP response headers.

- Status Code
- Content-Type
- Location
- Content-Length
- Set-Cookie

Along with headers, an HTTP response typically includes an HTTP body. And if it's a web page that was requested successfully, the HTTP body will contain the raw HTML code representing that web page.

URL
----

URL: `http://www.example.com:88/home?item=book`

When you type the above URL into a web browser and hit ENTER, you are using the TCP/IP protocol to send an HTTP text message to a web server and requesting a specific resource from that web server. The URL can be broken into 5 parts:

- `http`: The **scheme** always comes before the colon and two forward slashes and tells the browser how to access the resource.
- `www.example.com`: The **host** tells the browser where the resource is located on the Internet.
- `:88`: The **port** indicates which port on the web server to send the request.
- `/home/`: The **path** indicates the specific resource requested from the web server.
- `?item=book`: The **query string** is made up of **query parameters** and are used to send data to the server.

While query strings are an easy way to send additional information to a server, there are several limitations.

- They have a maximum length.
- The data is not secure and completely visible in the URL.
- Certain reserved characters (e.g. `%`, `/`, `?`, `:` `@`, `&`) must be encoded to be used in an URL.

HTTP Methods
-------------

The **Request Method** is a request header that tells the web server what to do with the resource requested by the HTTP message. The two most common types of HTTP methods are **GET** and **POST**.

**GET** is used to retrieve a resource (e.g. web page) from the server. They are read-only, meaning nothing is modified on the server. GET requests respond with a 200 (OK) if the resource was found and 404 (NOT FOUND) if the resource was not found. If the response from a GET request is HTML and that HTML references other resources, a browser will automatically send additional GET requests for those resources.

**POST** is used to send or submit data (e.g. sign up a new user) to the server with the intent of changing values stored on the server. Unlike a GET request that relies on query parameters, a POST request allows you to use a form to submit data using the HTTP body. When used with the HTTPS protocol, this allows a browser to make sure the sent data is secure. POST requests respond with a status code 201 (CREATED) along with a `Location` header containing a link that issues a GET request to redirect the browser to a new resource.

Stateful Applications
---------------------

HTTP is a **stateless** protocol, meaning each request/response pair is completely independent of the previous one. This means that the server does not need to store information between requests. This quality makes HTTP a resilient protocol but developers must employ various tricks to build stateful web applications.

One trick is to use a **session** to store state during requests. The web server creates a **session identifier**, a unique token identifying the client, and sends it in a `set-cookie` response header. The browser stores `session id` as a cookie in local storage, and on subsequent requests, includes it as a `cookie` request header. When the server receives subsequent requests, it inspects the value of the `cookie` header, ensures that the `session id` is still valid, and retrieves any session-specific data to be included in the HTTP response body.

In between requests, the browser stores the `session id` in an HTTP cookie on your local computer.  If you close your browser and computer, the cookie is still there, at least until you clear your browser history and delete your cookies.

Another trick is through the use of `AJAX`, short for Asynchronous Javascript and XML. It allows browsers to send requests and process responses *without a full page refresh*. The responses from these requests are processed by what's called a callback. The callback is able to use client-side Javascript code to update the current page's HTML without actually refreshing the page.

Rack
-----
Rack is a Ruby interface that gives application developers a stable communications protocol between their application code and web servers. Rack helps alleviate the need to write and maintain lower level code related to working with different web servers.

To use Rack, an app must respond to a `call` method that takes an `env` hash as an argument and returns an array with 3 elements:
- HTTP status code (as a string)
- HTTP headers (as a set of key-value pairs inside a hash)
- HTTP response body (as an object that responds to `each`, usually `Array`)

```ruby
class HelloWorld
  def call(env)
    [
      '200',
      {'Content-Type' => 'text/plain'},
      ['Hello World']
    ]
  end
end
```

To run the app on the web server, the `rackup` command is used to run a rackup file (`config.ru`) that specifies the rack-based application.

```ruby
require_relative 'hello_world'

run HelloWorld.new
```

Sinatra and Ruby on Rails are web application frameworks that adhere to the Rack specification, make use of Rack's libraries, and are therefore categorized as "rack based" frameworks.

Sinatra
-------

Sinatra is a Ruby library (or framework) that makes it simple to write Ruby code that runs when a browser visits a particular URL. First we `require` `sinatra` and `sinatra/reloader`, which causes the app to reload its files every time we load a page, making development easier.

```ruby
require "sinatra"
require "sinatra/reloader"
```

The mapping of a URL pattern to some Ruby code is accomplished by defining a *route*.

```ruby
  get '/' do
    .. show something ..
  end
```

Each URL pattern is associated with a block of code that executes when the pattern is matched. Routes are matched in the order they are defined, and only the first match is executed. The value that is returned by the block is then sent to the browser.

Route patterns may include named parameters, accessible via the *params* hash:

```ruby
get '/hello/:name' do
  "Hello #{params['name']}!"
end
```

Routes may also utilize query parameters:

```ruby
get '/posts' do
  # matches "GET /posts?title=foo&author=bar"
  title = params['title']
  author = params['author']
end
```

The return value of a route block determines the response body passed to the web server and hence the browser.

Static files are served from the `./public` directory.

View templates are files that contain text that is converted to HTML before being sent to a browser in an HTTP response. In Sinatra, views are served from the `./views` directory. When matched, the route below renders `views/index.erb`.

```ruby
  get '/' do
    @title = "My Page"
    erb :index
  end
```

Any Ruby code can be placed in an .erb file by including it between `<%` and `%>`. If you want to display the return value, you use a special start tag, `<%=`.

```ruby
<h1><%= @title %></h1>
```

Templates take a second argument, the options hash:

```ruby
get '/' do
  erb :index, :layout => :layout
end
```

This will render `views/index.erb` embedded in the `views/layout.erb`.

Any code in a `before` filter is evaluated before each request and any code in an `after` filter is evaluated after each request. Instance variables set in `before` filters and routes are accessible by `after` filters:

```ruby
before do
  @note = 'Hi!'
end

after do
  puts @note
end
```

The top-level `helpers` method is used to define helper methods for use in route handlers and templates:

```ruby
helpers do
  def bar(name)
    "#{name}bar"
  end
end

get '/:name' do
  bar(params['name'])
end
```

A session is used to store state during requests. Enabling sessions provides one session hash per user session. The hash is stored as a cookie in the browser and included as a header in every HTTP request except the first request. The first request is when the server creates the session id and responds with a `set-cookie` header, instructing the browser to create and store a cookie.

The `configure` block is executed once at startup of the web server.

```ruby
configure do
  enable :sessions
end
```

You can add and remove values from the `session` hash within a Sinatra route, view, method, or view helper.

```ruby
get '/:value' do
  session['value'] = params['value']
end
```

It is possible to set the status code, headers, and body with the return value of the route block.

```ruby
get '/foo' do
  status 418
  headers \
    "Allow"   => "BREW, POST, GET, PROPFIND, WHEN",
    "Refresh" => "Refresh: 20; http://www.ietf.org/rfc/rfc2324.txt"
  body "I'm a tea pot!"
end
```

You can trigger a browser redirect with the `redirect` helper method. Using `redirect` interrupts the processing of a request and prevents any later code from executing.

```ruby
  get '/foo' do
    redirect '/bar'
  end
```

Security
--------

To prevent a hacker from trying to read your HTTP messages by *packet sniffing*, **HTTPS** is employed. When using HTTPS, every HTTP message is encrypted by **TLS** cryptographic protocol. TLS does two things: (1) uses certificates to communicate with remote servers and confirms the identity of the web server and (2) generates and exchange encryption keys with the browser to secure all HTTP requests and responses transmitted between two computers.

**Same-origin policy** is a concept that permits resources from the same site to access each other but prevents access to resources on different sites. The documents must have the same protocol, hostname, and port. The **cross-origin resource sharing (CORS)** policy relaxes this policy by allowing servers to use a header to explicitly list additional allowable hosts.

A `session id` is often employed to avoid the need for the user to re-authenticate (i.e. re-login) for every single request, as long as the it is included as a `Cookie` in a request header. **Session hijacking** is when a hacker somehow gets a hold of a user's `session id` and uses it to access the user's session and any access that user is granted on a website. To minimize this vulnerability, most sessions have an expiration date, after which the `session id` is no longer valid. Using HTTPS also reduces the change that a hacker can steal a `session id`.

**Cross-site scripting (XSS)** is an attack that can happen when a user is allowed to input HTML or Javascript in a web form. The solution to preventing this attack is to *escape* any values that come from an untrusted source. This involved replacing certain characters in the text with HTML entities that the browser won't interpret as code. The characters that must be escaped include quotes, greater or less than operators, and more. Sinatra provides the ability to automatically escape all output. Since this will automatically escape all `erb` return values, you must replace `<%=` with `<%==` where you want to disable auto-escaping.

```ruby
configure do
  set :erb, :escape_html => true
end
```

In addition,
