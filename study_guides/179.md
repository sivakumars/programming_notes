179 Study Guide
=================

Notes created while preparing for Assessment 179. This assessment is designed to test knowledge of course 170 and will focus on HTTP, the Web, and Sinatra.

Internet
---------

The Internet is a tangible, physical structure made to move information. Like the postal service, the Internet sends things from one place to another, but instead of letters and packages, it sends bits (or binary information). These bits are usually sent through either electricity (ethernet/copper cable), light (fiber optic cable), or radio (wireless transmission).

Ethernet cable is cheap but suffers from significant signal loss over long distances. Fiber optic is fast and doesn't suffer from much signal loss but is expensive. Wireless translates bits into radio waves of different frequencies but suffers from very significant signal loss. The physical methods for moving bits has and will continue to change, but the underlying binary representation of information and the protocols for sending and receiving that information have and will likely stay the same.

TCP/IP
-------

In addition to the physical structure, the Internet comprises of a design philosophy that is expressed in a set of protocols. A protocol is defined as an agreed-upon set of rules for sending and receiving information.

The first protocol helps a computer send information to another computer. Every Internet-connected computer has a unique address, analogous to a person's mailing address, and that address is used to determine where to send information. Let's say a user wants to use the Internet to view a website. To do this, the user's computer must send a message to the website's computer requesting the contents of the website. After entering the site URL, http://www.example.com/, into a web browser, the website request is first forwarded to the Domain Name System (DNS), which translates the human-friendly site (www.example.com) into the address of the website's computer, 90.32.123.122), called an IP address. With the IP address in hand, the browser knows where to send its message requesting the website. This system of assigning addresses to computers and routing information between computers based on these addresses comprise what's known as the Internet Protocol (IP).

Like a car, Internet information doesn't usually travel in a fixed or direct path. If there happens to be construction or traffic on a particular route, a faster route is selected. In addition, the entire message isn't sent at once; it's broken into tiny chunks called packets. Each packet is tagged with an IP header, which includes the source and destination IP addresses, and a TCP header, which includes the source and destination port numbers. Once broken up, the packets travel independently, optimizing their own routes, and are reassembled into the original message once all arriving successfully at the destination computer. This process of breaking up, sending, verifying, resending, and reassembling packets is called transmission control protocol (TCP).

Together, this system of communication is known as the **TCP/IP** suite.

When computers exchange messages, they're either sending a request for information or responding to a request for information; this is known as the "request-response" messaging pattern. The computer that requests information is called the "client" and the computer that returns a response is called the "server". The content of these messages is just text, and the language used is the hypertext transfer protocol (HTTP). HTTP is a set of rules outlining the specific information that a request or response must contain and the specific format that a request and response must follow.

To summarize the section: on the Internet, computers send HTTP messages, either requests or responses, over TCP/IP connections.

URL
----

When you a URL into a browser and hit ENTER, the TCP/IP protocol is used to send an HTTP message requesting a specific resource from a web server.

`URL: http://www.example.com:88/home?item=book`

The URL can be broken into 5 parts:

- `http`: The **scheme** always comes before the colon and two forward slashes and tells the browser how to access the resource.
- `www.example.com`: The **host** tells the browser where the resource is located on the Internet.
- `:88`: The **port** indicates which port on the web server to send the request.
- `/home/`: The **path** indicates the specific resource requested from the web server.
- `?item=book`: The **query string** is made up of **query parameters** and is used to send additional data to the server.
- `GET`: When you press ENTER to submit a URL in a browser, the **request method** is generally assumed to be a GET request. A few other request methods (e.g. POST, PUT, DELETE) are available to send different types of HTTP messages.

The host and port (if included) are used by TCP/IP to tag and route the packets that are eventually transmitted across the Internet.

The path, query parameters, and request method are included as part of the HTTP request, along with additional data presented in the section below.

HTTP
------

To issue an HTTP request, a method ("GET") and path ("/") are required. Query parameters are optional.

`GET / HTTP/1.1`

To issue a corresponding HTTP response, a status code ("200 OK") is required.

`HTTP/1.1 200 OK`

In addition to these required components, an HTTP request/response can contain headers and a body.

HTTP headers typically contain various metadata that a browser or a web server chooses include as part of a request.

Common HTTP Request Headers:
- Content-Type
- Cookie
- Host
- User-Agent

Common HTTP Response Headers:
- Content-Type
- Location
- Content-Length
- Set-Cookie

Lastly, the HTTP body often contains the main content of the message. Depending on the nature of the request, it may be empty. In a POST request, the body will contain the data submitted in the form. In an HTTP response, the body will often contain raw HTML code representing a requested web page.

HTTP Methods
-------------

The **Request Method** is a request header that tells the web server what to do with the resource requested by an HTTP message. The two most common types are **GET** and **POST**.

**GET** is used to retrieve a resource (e.g. web page) from the server. The request is read-only, which means nothing is modified on the server. GET requests respond with a "200 OK" if the resource is found and "404 NOT FOUND" if the resource couldn't be found.

If an HTTP response's body contains HTML code that references additional resources, a browser will automatically issue GET requests to retrieve those resources. If you open a browser's *Network* tab, you'll notice the loading of one URL often results in multiple GET requests, all used to display one web page.

**POST** is used to submit new data to the server. It is most often used when submitting HTML form data (e.g. signing up a new user).  Successful POST requests respond with a "201 Created" or "303 See Other". Unsuccessful POST requests might respond with "415 Unsupported Media Type" or "422 Unprocessable Entity"

A successful POST request often includes a `Location` header in its HTTP response. The inclusion of the header triggers the browser to immediately issue a GET request to that location. This process is called a **redirect**. The importance of the redirect is that it means the browser's latest request was a GET, and if the user were the refresh their page, that same GET request would be resubmitted. If, on the other hand, the browser's last request is a POST, a page refresh would result in duplicate data being submitted to the server.

Stateful Applications
---------------------

HTTP is a **stateless** protocol, meaning that the server is not required to retain information (i.e. track state) about a user over multiple requests. This simplifies the HTTP protocol and reduces the amount of data that is sent in a message. In order to provide a superior user experience, developers employ various tricks to preserve state in their applications.

One trick is to use a **session identifier** to identify a particualr user. Upon receiving an HTTP request from a new user, a web server creates a unique session id token and includes it as a `set-cookie` header in its HTTP response. The browser stores the value of the header in its local storage as a **cookie**. And on subsequent HTTP requests, the browser includes it as a `cookie` header. When the web server receives an HTTP request that includes `cookie` header, it uses the session id value to retrieve data specific to that user.

Another trick is the use of **AJAX**, or Asynchronous Javascript and XML. It allows browsers to send requests and process responses without reloading the page. The responses are processed by what's called a callback, which is uses client-side Javascript to update the HTML of a page without actually reloading the page.

Security
--------

Since HTTP is transmitted over TCP/IP as text, it can be easily read by anyone employing a technique called *packet sniffing*. To prevent a hacker from reading your HTTP messages, an encryption protocol named **TLS** is used to obscure the message's content. When TLS is used, it practically ensures that only the intended recipient of your HTTP message can read it. The use of *HTTP over TLS* is indicated when *http* is replaced with *https* in a URL.

**Same-origin policy** is a concept that permits resources from the same host to access each other but prevents access to resources on different hosts. The resources being requested must use the same protocol, hostname, and port. The **cross-origin resource sharing (CORS)** policy relaxes this policy by allowing servers to use a header to explicitly allow additional hosts.

**Session hijacking** is when a hacker gets a hold of a user's session id and uses it to impersonate the user and access their data through the website. To minimize this risk, sessions often have an expiration date, after which the `session id` is no longer valid. The use of HTTPS also reduces the chance of session hijacking.

**Cross-site scripting (XSS)** is an attack that is possible when a user is allowed to input raw HTML or Javascript in a web form. The solution to preventing this attack is to *sanitize* the user input by *escaping* submitted form data. Escaping means to replace certain characters with text that the browser won't interpret as code. Some characters that must be escaped include quotation marks and greater or less than symbols.

Rack
-----
Rack is an interface that gives Ruby apps a standard protocol to communicate to the various web servers.

To use Rack, an app must respond to a `call` method that takes an `env` hash as an argument and returns an array with 3 elements:
- HTTP status code (as a string)
- HTTP headers (as a set of key-value pairs inside a hash)
- HTTP response body (nested in an object that responds to `each`, e.g. Array)

```ruby
class HelloWorld
  def call(env)
    [
      '200',
      {'Content-Type' => 'text/plain'},
      ['Hello World']
    ]
  end
end
```

To deploy the app on the web server, the `rackup` command is used to run a rackup file (`config.ru`) that specifies the location of the rack-enabled application.

```ruby
require_relative 'hello_world'

run HelloWorld.new
```

Sinatra and Ruby on Rails are web application frameworks that adhere to the Rack specification and are therefore categorized as "rack based" frameworks.

Sinatra
-------

Sinatra is a Ruby library (or framework) that makes it simple to write Ruby code that runs when a browser visits a particular URL.

To use Sinatra, we must `require sinatra`. It's also good to `require sinatra/reloader`, a feature that automatically reloads the app whenever we load a page, making development easier.

```ruby
require "sinatra"
require "sinatra/reloader"
```

The mapping of a URL pattern to Ruby code is accomplished by defining a *route*. Each URL pattern is associated with a block of code that executes when the pattern is matched. Routes are matched in the order they are defined, and only the first match is executed. The value that is returned by the block is then sent to the browser.

```ruby
get '/' do
  "Hello World."
end
```

Route patterns may include named parameters, accessible via the *params* hash:

```ruby
get '/hello/:name' do
  "Hello #{params['name']}!"
end
```

Routes may also utilize query parameters:

```ruby
get '/posts' do  # matches "GET /posts?title=foo&author=bar"
  title = params['title'] # => "foo"
  author = params['author'] # => "bar"
end
```

A route's block return value determines the HTTP response body passed by the web server to the browser.

View templates are files that contain text that is converted to HTML before being sent to a browser in an HTTP response. In Sinatra, views are served from the `./views` directory. So the route below will render `views/index.erb`.

```ruby
get '/' do
  @title = "My Page"
  erb :index
end
```

View templates can take an optional second argument, the options hash. The code below will render `views/index.erb` embedded in the `views/layout.erb`.

```ruby
get '/' do
  erb :index, :layout => :layout
end
```

Ruby code can be executed in an .erb file by including it between `<%` and `%>` tags. To display the return value of Ruby code, a special start tag, `<%=`, is used.

`<h1><%= @title %></h1>`

Code places within a `before` filter evaluates before each request and code placed within an `after` filter evaluates after each request. Instance variables assigned in a route handler or in a `before` filter are accessible by `after` filters:

```ruby
before do
  @note = 'Hi!'
end

after do
  puts @note
end
```

The top-level `helpers` method is used to define methods that can be used in route handlers and view templates:

```ruby
helpers do
  def bar(name)
    "#{name}bar"
  end
end

get '/:name' do
  bar(params['name'])
end
```

The `configure` block is executed once at startup of the web server. The code below enables sessions and provides a `session` hash stored as a cookie in the user's browser.

```ruby
configure do
  enable :sessions
end
```

Values can be added/removed from the `session` hash within a Sinatra method, route handler, or view template.

```ruby
get '/:value' do
  session['value'] = params['value']
end
```

A browser redirect can be triggered using the built-in `redirect` helper method. The method interrupts processing of a request and exits the route handler.

```ruby
get '/foo' do
  redirect '/bar'
end
```

Sinatra provides the ability to automatically escape all output. Since this will automatically escape all `erb` return values, you must replace `<%=` with `<%==` where you want to disable auto-escaping.

```ruby
configure do
  set :erb, :escape_html => true
end
```

In Sinatra, static files are served from the `./public` directory.
