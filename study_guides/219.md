219 Study Guide
=================

Notes created while preparing for Assessment 219. This assessment is designed to test knowledge of course 210 and will focus on Computational Thinking and JavaScript Programming.

Introduction
------------

**JavaScript** is a high-level, interpreted, object-oriented programming language that was created in 1994 by Brendan Eich. The purpose of the language was to provide a way for web sites to be dynamic and more interactive.

Variables
----------

In JavaScript, variables are declared before they are used with the `var` keyword. After a variable is declared, you can use the `=` operator to assign a value to it. Any variable that is declared (but not assigned) is initialized to the value `undefined`.

```javascript
var name;
console.log(name);      // "undefined"
console.log(last_name); // ReferenceError
```

JavaScript is a *loosely typed* or *dynamically typed* language, meaning you don't have to declare the data type of a variable ahead of time. In addition, you can reassign a variable to a different data type without error.

Primitive Data Types
-------------------

A **primitive** is a data type that represents one single value; it's not an object.  JavaScript (ES5) contains five primitive data types: `number`, `boolean`, `string`, `null`, and `undefined`.

All primitives are *immutable*, in other words, their value cannot be changed in memory by any operation or function. Therefore, to change the value of a variable, it must be reassigned.

All other data types in JavaScript, including arrays and functions, are objects. An object is a container that can hold primitives or other objects. Objects *are* mutable, which means you can modify their contents without reassignment.

Except for `null` and `undefined`, all primitives have object equivalents that wrap around their primitive values. This means that each primitive value actually has access to properties and methods, and can be treated as if they were an object.

### Number

Unlike most other languages, JavaScript uses a floating point system to represent numbers. A common issue that arises from this implementation is that there seem to be rounding errors when performing operations on numbers.

`0.1 + 0.1; // returns 0.30000000000000004, not 0.3!`

Therefore, it's best to avoid fractional numbers and instead use an integer of the smallest relative units. For example, if you're working with money, represent the amount in an integer value of cents rather than a decimal value of dollars. And when working with time, use seconds rather than hours.

### NaN

The special number value of `NaN` indicates an illegal operation on numbers. Comparing `NaN` with any value (including itself) evaluates to `false`.

```javascript
Number('abc'); // NaN
Math.sqrt(-1); // NaN
undefined + 1; // NaN

typeof(NaN);   // "number"
NaN === NaN;   // false
```

Since we can't use the usual comparison operators to compare `NaN` with other values, JavaScript provides an `isNaN` function. But even this doesn't work that well. The `isNaN` function returns true for any value that is "not a number".

```javascript
NaN === NaN;    // false
isNaN(NaN);     // true
isNaN('WTF');   // true
```

We can create a custom function that also checks if the value is a number.

```javascript
function isValueNaN(value) {
  return typeof(value) === "number" && isNAN(value);
}
```

Explicit Type Conversions
--------------------------

A **coercion** or **conversion** is an operation that attempts to convert a variable from one data type to another. Since primitives are immutable, JS doesn't actually "convert" the values but instead returns a new value of the proper type.

Although there are two ways used to convert strings to numbers, the `parseInt` method with the radix specified is preferred.

```javascript
Number('123');            // 123
Number('abc123');         // NaN
parseInt('123', 10);      // 123
parseInt('123.1', 10);    // 123
parseFloat('123.1');      // 123.1
```

A number (or a boolean) can be converted to a string with either the String constructor function or by calling the `toString` method on an object. The constructor method is preferred because it doesn't thrown an error when passing `null`.

```javascript
String(123);              // "123"
(123).toString();         // "123"
String(null);             // "null"
(null).toString();        // TypeError
```

The `Boolean()` function can convert any value into a boolean based on JavaScript truthiness rules.

```javascript
Boolean(false);           // false
Boolean(null);            // false
Boolean(undefined);       // false
Boolean(0);               // false
Boolean(NaN);             // false
Boolean('');              // false
Boolean(' ');             // true
Boolean(1);               // true
Boolean(true);            // true
```

But since all non-empty strings are truthy, don't expect "false" to be converted to `false`. Instead, compare a boolean string value to the string "true" to determine it's boolean value.

```javascript
Boolean('false');         // true
var b = 'false';
b === 'true';             // false
```

Implicit Type Conversions
-------------------------

When evaluating expressions involving different data types, JavaScript will attempt to **implicitly** (or automatically) convert one of the types to match the other. While it seems convenient, implicit conversions can result in unexpected bugs. Therefore, implicit type conversions should generally be avoided. But it's good to be familiar with them since they are often used out in the wild.

### Plus (+) Operator

The unary plus operator converts values into numbers.

```javascript
+('123');         // 123
+('abc123');      // NaN
+(undefined);     // NaN
+('');            // 0
+(null);          // 0
+(false);         // 0
+(true);          // 1
```

The binary plus operator indicates addition for numbers or concatenation for strings. When mixed, the string conversion will take precedent.

```javascript
1 + true;         // 2
'123' + 123;      // "123123"
123 + '123';      // "123123"
'a' + null;       // "anull"
```

### Other Arithmetic Operators

Since the `-`, `*`, `/`, and `%` operators are only defined for numbers, JavaScript attempts to coerce both operands to numbers.

```javascript
2 - true;         // 1
'123' * 3;        // 369
'8' - '1'         // 7
```

### Relational Operators

The relational operators are defined for numbers (numeric comparison) and strings (lexicographic order). In this case, the number conversino will take precedent.

```javascript
50 > '6';         // true
'50' > '6'        // false
123 > 'a';        // false (because 'a' is coerced to NaN)
123 <= 'a';       // false (because comparison with NaN is always false)
```

### Equality Operators

When using the Equal (`==`) operator, JS tries to implicitly convert operands of different types. Therefore, it's best to use Strict Equal (`===`), which does not perform any type conversions.

```javascript
var str = '3';
var num = 3;

str == num;  // true
str === num; // false
```

### Logical Operators

For non-boolean operand values, logical operators exhibit some possibly unexpected behavior.

With the logical AND (`&&`), if the first operand is "falsy", it is returned. Otherwise, the second operand is returned.

With the logical OR ('||'), if the first operand is "truthy", it is returned. Otherwise, the second operand is returned.

### Increment and Decrement Operators

When used as a standalone expression, it doesn't matter whether the increment (`++`) or decrement (`--`) operators appear before or after the operand.

When part of an assignment, however, they behave differently.

```javascript
var a;
var b;
var c;

a = 1;
b = a++;    // b = 1; a = 2
c = ++a;    // a = 3; c = 3
```



Conditionals
-------------

In JavaScript, the `if...else` conditional works as expected and similar to other languages. The `switch` statement, however, has a unique quirk. Like the `if` statement, the `switch` statement looks for the first `case` label that matches. But instead of returning out of the statement, it continues to execute all subsequent `case` and `default` blocks (whether they match or not) until it encounters a `break` or the statement ends. This behavior is known as execution that "falls-through" to the next case. To correct the behavior, insert a `break` at the end of each `case` statement.

```javascript
var condition = 'yes';

switch(condition) {
  case 'yes':
  console.log('This should be logged.');
  break;
  case 'no':
  console.log('This should not be logged.');
  break;
  default:
  console.log('I am boring.')
}

// console output
'This should be logged.'
```

Functions
---------

A function is a piece of code that executes a list of instructions and returns a value. A function name is just a local variable that happens to have a Function as it's value. The code below declares a variable `startle` with a function as it's value.

```javascript
function startle() {
  console.log('Yikes!');
}

var surprise = startle;

surprise();                  // logs: "Yikes" and returns "undefined"
```

A function is called using the function name and appending `()`. If a function does not contain an explicit `return` statement, the function implicitly returns `undefined`.

During execution, any arguments passed are made available to the function as local variables with the same names as the function's parameters. Within the function body, we call them arguments.

```javascript
function add(a, b) {
  return a + b
}

add(1, 3);                  // 4
add(1, 3, 5);               // 4
add(1);                     // NaN (1 + undefined = NaN)
```

Note that calling a Function with too few or too many arguments *does not raise an error*. Missing arguments will be assigned a value of `undefined`. Superfluous arguments, however, are accessible using the `arguments` object that is available within every function and contains a list of all arguments passed to the Function.

### Function Arguments Object

The `arguments` object is an *Array-like* local variable that is available inside all Functions. It contains all the arguments passed to the Function, no matter how many arguments the Function's definition includes.

The `arguments` object's elements can be accessed using bracket notation and it has a `length` property. Beyond that, it does not itself support any other features of an `Array` object. You can, however, copy its elements into an `Array` object using the `slice` method.

```javascript
var args = Array.prototype.slice.call(arguments);
```

Function Scope
---------------

A variable's scope is defined by where the variable was declared and determines where in a program the variable is accessible for use.

JavaScript is said to have "lexical scope". This means that (1) the scope of the variables is determined by their position in the code hierarchy and (2) a block of code also has access to anything defined in its surrounding (or outer) scopes. When you attempt to retrieve the value of a variable, JavaScript searches the current scope first and then proceeds to search the surrounding scopes. Once it finds a matching variable, it returns its value. This also means that variables declared in an inner scope can *shadow*, or hide, a variable with the same name declared in an outer scope.

In JavaScript, every function creates a new scope. And due to *lexical scoping*, every function has access to any variables defined in a surrounding scope. But it's important to know that the function has access to any variables that are available where the function was defined, not where it is eventually called. In other words, every JavaScript function is actually a **closure**, where it has access to the function definition (obviously) but also the environment in which that function was defined. That environment consists of any local variables that were in-scope at the time the function (or closure) was defined.

```javascript
var first_name = 'Nitin';

function greet() {
  var last_name = 'Savant'
  console.log(first_name + ' ' + last_name);
}

greet();                    // Logs: "Nitin Savant" and returns "undefined"
console.log(first_name);    // Logs: "Nitin" and returns "undefined"
console.log(last_name);     // ReferenceError: last_name is not defined
```

In the example above, the `greet` function can access `first_name` that was declared in a surrounding scope. And it can access `last_name` that was declared in its current scope. But, the surrounding scope cannot access `last_name` because it's only accessible within the function in which it was declared.

Variable Assignment
-------------------

When assigning a variable, JavaScript checks the current scope and then each higher scope, looking for a variable with the same name to reassign. If it can't find a matching variable, **it creates a new global variable instead**. This behavior is the source of subtle bugs.

```javascript
function assign() {
  var country = 'India';
  country2 = 'Slovenia';
}

assign();
console.log(country2);      // Logs: "Slovenia" (country2 is global)
console.log(country1);      // ReferenceError: country1 is not defined
}
```

Function Declarations and Function Expressions
-----------------------------------------------

In addition to the **function declaration** demonstrated above, a function can also be defined using a **function expression**. In a function declaration, the function is not assigned to a variable; instead, the function variable is function itself and the function name acts as the variable name.

A function expression defines a function as part of a variable assignment. In the code below, we define an anonymous function and assign it to the variable `greet`.

```javascript
var greet = function () {
  return 'hello';
};

greet();                    // "hello"
```

You can also define a named function and assign it to the variable `greet`. But the function name is only accessible within the function. Though most function expressions use anonymous functions, named function expressions are useful for debugging.

```javascript
var greet = function hello() {
  console.log(typeof hello);
  return 'hello';
};

greet();                    // Logs "function" and returns "hello"
hello();                    // ReferenceError: hello is not defined
```

Hoisting
-------

The major difference between function declarations and function expressions is described by JavaScript's **hoisting** behavior.

When JavaScript code is executed, the JavaScript interpreter first looks for function declarations and loads them into memory. Next, it looks for all other variable declarations and loads them into memory. Finally, it returns to the top of the code and runs the remaining lines in order.

This behavior can best be understood by visualizing all variable declarations being hoisted to the top of the current scope of code. In other words, declaring a variable anywhere in a scope is equivalent to declaring it at the top of the scope.

While variable assignments are often coupled with variable declarations, JavaScript hoists only declarations, not assignments.

```javascript
console.log(a);     // Logs: "undefined"
console.log(b);     // ReferenceError: b is not defined.

var a = 'hello';

console.log(a);     // Logs: "hello"
```

In the code above, `var a` is hoisted above `console.log(a)`, which is why it logs "undefined" as opposed to throwing a ReferenceError as it does for `console.log(b)`.

Since function expressions are just variable declarations, they behave similarly. The variable declaration is hoisted but the variable assignment remains.

```javascript
console.log(hello());           // Logs: "undefined"
console.log(goodbye());          // ReferenceError: goodbye is not defined

var hello = function () {
  return 'hello';
};

console.log(hello());           // Logs: "hello"
```

Objects
--------

In JavaScript, objects serve multiple roles. As in Ruby, an object can be used as a container to bundle related data and behavior. Using objects in this manner, you're able to create programs in an object-oriented style.

But since objects are simply structured as names and values, they resemble hashes (or associative arrays) and can be used as such. In JavaScript, these name-value pairs are known as the properties of an object.

When functions (i.e. specific behavior) are included as an object's property, we call them **methods**.

### Object Literal

Objects are initialized using an object literal. The property name for an object can be any valid string and the property value can be any valid expression. If, however, the name is not a valid identifier, or non-negative integer, it must be enclosed in quotes.

**Note:** A valid identifier may not start with a digit and can only contain alphanumeric characters.

```javascript
var object = {
  a: 1,
  2: 'hello',
  '2b': 2 + 1,
  'a b': {
        first: 'Nitin',
        last: 'Savant',
  },
};
```

### Accessing and Assigning Properties

All properties that are also valid identifiers can be accessed and assigned using "dot-notation".

```javascript
var name = {
  first: 'Nitin',
};

name.first                // 'Nitin'
name.last                 // undefined
name.last = 'Savant'      // 'Savant'
name                      // { first: 'Nitin', last: 'Savant' }
```

If a property is not a valid identifier, "bracket-notation" must be used. When using bracket-notation, unless you're passing an expression (e.g. variable, number), quotes are required. An expression cannot be passed using dot-notation.

```javascript
var object = {
  a: 1,
  2: 'hello',
  '2b': 3,
};

var num = 2;

object.a;         // 1

object.2;         // SyntaxError: Unexpected number
object[2];        // 'hello'
object[num];      // 'hello'

object[2b] ;      // SyntaxError: Invalid or unexpected token
object['2b'] ;    // 3
```

The `delete` keyword is used to delete properties from an object.

```javascript
var name = {
  first: 'Nitin',
  last: 'Savant',
};

delete name.first;
name;                       // { last: 'Savant' }
```

Arrays
-------

Arrays are the basic collection type used in JavaScript, and the hold values that are indexed by a non-negative integer. But JavaScript Arrays are really just a special type of JavaScript Object.

```javascript
var array = [];
typeof array;   // "object"
```

To determine whether a value is an Array versus an Object, JavaScript provides the `Array.isArray()` function.

```javascript
var array = [];
Array.isArray(array); // true
```

You can even add properties to an array and yet it remains an array.

```javascript
var array = [];
array['name'] = 'Nitin';

array                     // [ name: 'Nitin' ]
Array.isArray(array);     // true
```

### Length Property

Each Array object has a `length` property that returns a value one greater than the largest array index. Remember that an array index must be a non-negative integer. If there are no elements in the array, it returns 0.

```javascript
var array = [];
array.length;                       // 0

array = ['Nitin', 'Savant'];
array.length;                       // 2

array['middle'] = 'Gajendra';
array.length;                       // 2

array;                               // [ 'Nitin', 'Savant', middle: 'Gajendra' ]

Object.keys(array).length;          // 3
```

The `Object.keys` function can be leveraged to count all the properties in an Array object.

While you can use the `delete` method on Array objects, it's best to use `splice` instead.

Pass-by-Reference vs. Pass-by-Value
-----------------------------------

### Primitives

When assigning a variable to a primitive, JavaScript creates a new value in memory and points the variable to it. If you were to assign a second variable to the first variable, JavaScript creates a completely new value in memory containing a copy of the first variable's value.

Since they are pointing to two different values in memory, anything you do with the first variable has no effect on the second variable.

```javascript
var first = 'Nitin';
var second = first;

var first = 'Savant';
second;                 // 'Nitin'
```

This demonstrates that JavaScript is pass-by-value when it comes to dealing with primitives.

Ruby behaves similarly for it's Number and Boolean vales. But JavaScript differs from Ruby here when it comes Strings. In Ruby, when you assign a second string to the value of the first string, it simply creates a pointer to the same value in memory. Therefore, when you mutate the first string, the second string is affected.

```ruby
first = 'Nitin';
second = first;

first << ' Savant';
second;             # 'Nitin Savant'
```

### Objects

When it comes to objects, the behavior appears similar at first. In this example, we assign the first variable to an object, and then we assign the second variable to the same object.

As with primitives, when we reassign the first variable to a new object, JavaScript creates a new value in memory and the second variable remains unaffected.

```javascript
var first = { name: 'Nitin' };
var second = first;

first = { name: 'Savant'}
second;                 // { name: 'Nitin' }
```

Therefore, according to CS theory, JavaScript is purely pass-by-value for all data types (primitives and objects). In practice though, there is an extremely important distinction between primitives and objects.

```javascript
var first = { name: 'Nitin' };
var second = first;

first.name = 'Savant';
second;                 // { name: 'Savant' }
```

In this example, we reassigned a property of an object to a new value. And that reassignment **did affect** the second variable. When JavaScript assigns the second variable, it doesn't create a copy of its properties; instead it creates a reference that points to the same set of properties as the first object. Therefore, when you modify the properties of either object, the other one is exactly affected.

This behavior is sometimes informally called "call by sharing".

### Mutability

This distinction between primitives and objects demonstrates the concept of **mutability**.

Primitive values are *immutable*: you cannot modify them. Any operations on primitives return a new value of the same type.

Objects are *mutable*, specifically the values within them can be modified in-place without changing the identity of the object. In other words, you can modify an object without having to return a new object.

Pure Functions and Side Effects
-------------------------------

Due to lexical scoping in JavaScript, Functions can access and modify variables defined in surrounding scopes. Functions can also mutate Objects passed as arguments. These changes are called **side effects**.

On the other hand, when a Function doesn't have any side effects, we call it a **pure function**. A pure function only relies on its arguments to determine its return value and always returns a value. Given the same argument values, a pure function will always evaluate to the same result.

A **closure** is a Function that contains a reference to a variable in a surrounding scope. So by definition, a closure is not a pure function.

In order to better communicate whether your Function has a side effect or not, there are a few practices to follow:

1) When you want to use the return values of a pure function, you'll want to assign the result of your function call to some variable.

```javascript
function add(num1, num2) {
  return num1 + num2;
}

var result = add(3, 5);
result;                     // 8
```

2) When you use a function for its side effects, have the function accept the variable to be mutated as an argument.

```javascript
var numbers = [1, 2, 3];

function deleteElements(array, numToDelete) {
  array.length = array.length - numToDelete;
  return array;
}

deleteElements(numbers, 2);    // [1]
numbers;                       // [1]
```

3) Make functions pure to eliminate side effects and possible bugs.

```javascript
var numbers = [1, 2, 3];

function deleteElements(array, numToDelete) {
  var newArray = [];

  for (var i = 0; i < array.length - numToDelete; i++) {
    newArray.push(array[i]);
  }
  return newArray;
}

deleteElements(numbers, 2);             // 1
numbers;                                // [1, 2, 3]

numbers = deleteElements(numbers, 2);   // [1]
```
